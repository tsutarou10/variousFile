SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/syntax/markdown.vim
Sourced 1 time
Total time:   0.024920
 Self time:   0.000745

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:    *.markdown
                            " Last Change:  2020 Jan 14
                            
    1              0.000005 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000003 if !exists('main_syntax')
    1              0.000002   let main_syntax = 'markdown'
    1              0.000001 endif
                            
    1   0.024370   0.000195 runtime! syntax/html.vim
    1              0.000002 unlet! b:current_syntax
                            
    1              0.000007 if !exists('g:markdown_fenced_languages')
                              let g:markdown_fenced_languages = []
    1              0.000001 endif
    1              0.000002 let s:done_include = {}
    1              0.000007 for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              if s:type =~ '\.'
                                let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
                              endif
                              exe 'syn include @markdownHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
                              unlet! b:current_syntax
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
    1              0.000002 endfor
    1              0.000001 unlet! s:type
    1              0.000002 unlet! s:done_include
                            
    1              0.000003 if !exists('g:markdown_minlines')
                              let g:markdown_minlines = 50
    1              0.000000 endif
    1              0.000007 execute 'syn sync minlines=' . g:markdown_minlines
    1              0.000002 syn case ignore
                            
    1              0.000008 syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
    1              0.000005 syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
                            
    1              0.000009 syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
                            
    1              0.000015 syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
    1              0.000013 syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
                            
    1              0.000011 syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
    1              0.000006 syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            
    1              0.000003 syn match markdownHeadingRule "^[=-]\+$" contained
                            
    1              0.000009 syn region markdownH1 matchgroup=markdownH1Delimiter start="##\@!"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000008 syn region markdownH2 matchgroup=markdownH2Delimiter start="###\@!"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000006 syn region markdownH3 matchgroup=markdownH3Delimiter start="####\@!"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000007 syn region markdownH4 matchgroup=markdownH4Delimiter start="#####\@!"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000007 syn region markdownH5 matchgroup=markdownH5Delimiter start="######\@!"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000007 syn region markdownH6 matchgroup=markdownH6Delimiter start="#######\@!" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            
    1              0.000004 syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
                            
    1              0.000005 syn region markdownCodeBlock start="    \|\t" end="$" contained
                            
                            " TODO: real nesting
    1              0.000005 syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
    1              0.000004 syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
                            
    1              0.000003 syn match markdownRule "\* *\* *\*[ *]*$" contained
    1              0.000003 syn match markdownRule "- *- *-[ -]*$" contained
                            
    1              0.000004 syn match markdownLineBreak " \{2,\}$"
                            
    1              0.000008 syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
    1              0.000004 syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
    1              0.000006 syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
    1              0.000004 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
    1              0.000004 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
    1              0.000004 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
                            
    1              0.000017 syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\%(\_[^][]\|\[\_[^][]*\]\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
    1              0.000006 syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
    1              0.000004 syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
    1              0.000007 syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
                            
    1              0.000002 let s:concealends = ''
    1              0.000006 if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
    1              0.000001   let s:concealends = ' concealends'
    1              0.000001 endif
    1              0.000016 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=\*\|\*\S\@=" end="\S\@<=\*\|\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000013 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000015 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=\*\*\|\*\*\S\@=" end="\S\@<=\*\*\|\*\*\S\@=" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    1              0.000013 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    1              0.000013 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@=" end="\S\@<=\*\*\*\|\*\*\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000012 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
                            
    1              0.000006 syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
    1              0.000006 syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
    1              0.000006 syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*````*.*$" end="^\s*````*\ze\s*$" keepend
                            
    1              0.000003 syn match markdownFootnote "\[^[^\]]\+\]"
    1              0.000003 syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
                            
    1              0.000002 if main_syntax ==# 'markdown'
    1              0.000002   let s:done_include = {}
    1              0.000002   for s:type in g:markdown_fenced_languages
                                if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                  continue
                                endif
                                exe 'syn region markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*````*\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*````*\ze\s*$" keepend contains=@markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g') . s:concealends
                                let s:done_include[matchstr(s:type,'[^.]*')] = 1
    1              0.000001   endfor
    1              0.000005   unlet! s:type
    1              0.000001   unlet! s:done_include
    1              0.000001 endif
                            
    1              0.000004 syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
    1              0.000003 syn match markdownError "\w\@<=_\w\@="
                            
    1              0.000003 hi def link markdownH1                    htmlH1
    1              0.000002 hi def link markdownH2                    htmlH2
    1              0.000002 hi def link markdownH3                    htmlH3
    1              0.000002 hi def link markdownH4                    htmlH4
    1              0.000002 hi def link markdownH5                    htmlH5
    1              0.000002 hi def link markdownH6                    htmlH6
    1              0.000002 hi def link markdownHeadingRule           markdownRule
    1              0.000001 hi def link markdownH1Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownH2Delimiter           markdownHeadingDelimiter
    1              0.000001 hi def link markdownH3Delimiter           markdownHeadingDelimiter
    1              0.000001 hi def link markdownH4Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownH5Delimiter           markdownHeadingDelimiter
    1              0.000001 hi def link markdownH6Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownHeadingDelimiter      Delimiter
    1              0.000001 hi def link markdownOrderedListMarker     markdownListMarker
    1              0.000003 hi def link markdownListMarker            htmlTagName
    1              0.000002 hi def link markdownBlockquote            Comment
    1              0.000003 hi def link markdownRule                  PreProc
                            
    1              0.000003 hi def link markdownFootnote              Typedef
    1              0.000002 hi def link markdownFootnoteDefinition    Typedef
                            
    1              0.000002 hi def link markdownLinkText              htmlLink
    1              0.000005 hi def link markdownIdDeclaration         Typedef
    1              0.000003 hi def link markdownId                    Type
    1              0.000005 hi def link markdownAutomaticLink         markdownUrl
    1              0.000002 hi def link markdownUrl                   Float
    1              0.000003 hi def link markdownUrlTitle              String
    1              0.000001 hi def link markdownIdDelimiter           markdownLinkDelimiter
    1              0.000003 hi def link markdownUrlDelimiter          htmlTag
    1              0.000002 hi def link markdownUrlTitleDelimiter     Delimiter
                            
    1              0.000002 hi def link markdownItalic                htmlItalic
    1              0.000001 hi def link markdownItalicDelimiter       markdownItalic
    1              0.000002 hi def link markdownBold                  htmlBold
    1              0.000001 hi def link markdownBoldDelimiter         markdownBold
    1              0.000003 hi def link markdownBoldItalic            htmlBoldItalic
    1              0.000001 hi def link markdownBoldItalicDelimiter   markdownBoldItalic
    1              0.000002 hi def link markdownCodeDelimiter         Delimiter
                            
    1              0.000002 hi def link markdownEscape                Special
    1              0.000003 hi def link markdownError                 Error
                            
    1              0.000002 let b:current_syntax = "markdown"
    1              0.000002 if main_syntax ==# 'markdown'
    1              0.000001   unlet main_syntax
    1              0.000000 endif
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/syntax/html.vim
Sourced 1 time
Total time:   0.024149
 Self time:   0.005451

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Maintainer:           Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2019 Dec 24
                            " Included patch from Jorge Maldonado Ventura to add the dialog element
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    1              0.000004 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
    1              0.000001 endif
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000002 syntax spell toplevel
                            
    1              0.000001 syn case ignore
                            
                            " mark illegal characters
    1              0.000012 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000018 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000014 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000012 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000014 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    1              0.000031 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000016 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000014 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000005 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000006 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000005 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000006 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000004 syn keyword htmlTagName contained form hr html img
    1              0.000004 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000006 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000004 syn keyword htmlTagName contained select small sub sup
    1              0.000011 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000009 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000004 syn keyword htmlTagName contained abbr acronym bdo button col label
    1              0.000005 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    1              0.000005 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    1              0.000004 syn keyword htmlTagName contained article aside audio bdi canvas data
    1              0.000005 syn keyword htmlTagName contained datalist details dialog embed figcaption
    1              0.000005 syn keyword htmlTagName contained figure footer header hgroup keygen main
    1              0.000005 syn keyword htmlTagName contained mark menuitem meter nav output picture
    1              0.000004 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    1              0.000005 syn keyword htmlTagName contained slot source template time track video wbr
                            
                            " legal arg names
    1              0.000003 syn keyword htmlArg contained action
    1              0.000005 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000004 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000005 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000005 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000008 syn keyword htmlArg contained gutter height hspace id
    1              0.000004 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000004 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000005 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000005 syn keyword htmlArg contained size src start target text type url
    1              0.000005 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000006 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    1              0.000006 syn match htmlArg contained "\<\(aria-activedescendant\|aria-atomic\)\>"
    1              0.000007 syn match htmlArg contained "\<\(aria-autocomplete\|aria-busy\|aria-checked\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-colcount\|aria-colindex\|aria-colspan\)\>"
    1              0.000009 syn match htmlArg contained "\<\(aria-controls\|aria-current\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-describedby\|aria-details\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-disabled\|aria-dropeffect\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-errormessage\|aria-expanded\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-flowto\|aria-grabbed\|aria-haspopup\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-hidden\|aria-invalid\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-keyshortcuts\|aria-label\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-labelledby\|aria-level\|aria-live\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-modal\|aria-multiline\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-multiselectable\|aria-orientation\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-owns\|aria-placeholder\|aria-posinset\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-pressed\|aria-readonly\|aria-relevant\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-required\|aria-roledescription\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-rowcount\|aria-rowindex\|aria-rowspan\)\>"
    1              0.000006 syn match htmlArg contained "\<\(aria-selected\|aria-setsize\|aria-sort\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-valuemax\|aria-valuemin\)\>"
    1              0.000005 syn match htmlArg contained "\<\(aria-valuenow\|aria-valuetext\)\>"
    1              0.000003 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    1              0.000008 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000011 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000019 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    1              0.000016 syn keyword htmlArg     contained left top visibility clip id noshade
    1              0.000005 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000006 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000005 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    1              0.000018 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000013 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000014 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000014 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000007 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000005 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000004 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    1              0.000004 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    1              0.000004 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    1              0.000004 syn keyword htmlArg contained controls crossorigin default dirname download
    1              0.000005 syn keyword htmlArg contained draggable dropzone form formaction formenctype
    1              0.000004 syn keyword htmlArg contained formmethod formnovalidate formtarget hidden
    1              0.000005 syn keyword htmlArg contained high icon inputmode keytype kind list loop low
    1              0.000005 syn keyword htmlArg contained max min minlength muted nonce novalidate open
    1              0.000004 syn keyword htmlArg contained optimum pattern placeholder poster preload
    1              0.000004 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    1              0.000005 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    1              0.000003 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    1              0.000009 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000004 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+ contains=@Spell
    1              0.000001 else
    1              0.000015   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError,@Spell
    1              0.000005   syn match  htmlCommentError contained "[^><!]"
    1              0.000008   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc,@Spell
    1              0.000001 endif
    1              0.000007 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
    1              0.000016 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000010 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000004 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000015 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000013 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000004 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000008 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000004 if !exists("html_no_rendering")
                              " rendering
    1              0.000026   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000008   syn region htmlStrike start="<del\>" end="</del\_s*>"me=s-1 contains=@htmlTop
    1              0.000008   syn region htmlStrike start="<strike\>" end="</strike\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000013   syn region htmlBold start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000014   syn region htmlBold start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000011   syn region htmlBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000015   syn region htmlBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000012   syn region htmlBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000008   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000012   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000014   syn region htmlUnderline start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000011   syn region htmlUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000012   syn region htmlUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000011   syn region htmlUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000011   syn region htmlUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000008   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000008   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000013   syn region htmlItalic start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000007   syn region htmlItalic start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000010   syn region htmlItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000011   syn region htmlItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000007   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop
    1              0.000010   syn region htmlItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000007   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000008   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000004   syn match htmlLeadingSpace "^\s\+" contained
    1              0.000032   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a\_s*>"me=s-1 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    1              0.000008   syn region htmlH1 start="<h1\>" end="</h1\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlH2 start="<h2\>" end="</h2\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH3 start="<h3\>" end="</h3\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH4 start="<h4\>" end="</h4\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlH5 start="<h5\>" end="</h5\_s*>"me=s-1 contains=@htmlTop
    1              0.000014   syn region htmlH6 start="<h6\>" end="</h6\_s*>"me=s-1 contains=@htmlTop
    1              0.000040   syn region htmlHead start="<head\>" end="</head\_s*>"me=s-1 end="<body\>"me=s-1 end="<h[1-6]\>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000027   syn region htmlTitle start="<title\>" end="</title\_s*>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000003 syn keyword htmlTagName         contained noscript
    1              0.000004 syn keyword htmlSpecialTagName  contained script style
    1              0.000003 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    1   0.000726   0.000204   syn include @htmlJavaScript syntax/javascript.vim
    1              0.000002   unlet b:current_syntax
    1              0.000053   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000048   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    1              0.000007   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    1              0.000007   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
    1              0.000001   else
    1              0.000011     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    1              0.000010     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    1              0.000001   endif
    1              0.000008   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    1              0.000006   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    1              0.000004   hi def link htmlEventSQ htmlEvent
    1              0.000003   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    1              0.000009   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000005 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    1   0.003519   0.000244   syn include @htmlVbScript syntax/vb.vim
    1              0.000003   unlet b:current_syntax
    1              0.000028   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000005 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    1              0.000005 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    1              0.000004   syn keyword htmlArg           contained media
    1   0.015149   0.000248   syn include @htmlCss syntax/css.vim
    1              0.000002   unlet b:current_syntax
    1              0.000023   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    1              0.000005   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    1              0.002920   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    1              0.000006   hi def link htmlStyleArg htmlString
    1              0.000001 endif
                            
    1              0.000005 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
    1              0.000000 endif
                            
                            " The default highlighting.
    1              0.000004 hi def link htmlTag                     Function
    1              0.000004 hi def link htmlEndTag                  Identifier
    1              0.000003 hi def link htmlArg                     Type
    1              0.000003 hi def link htmlTagName                 htmlStatement
    1              0.000004 hi def link htmlSpecialTagName          Exception
    1              0.000003 hi def link htmlValue                     String
    1              0.000004 hi def link htmlSpecialChar             Special
                            
    1              0.000005 if !exists("html_no_rendering")
    1              0.000003   hi def link htmlH1                      Title
    1              0.000003   hi def link htmlH2                      htmlH1
    1              0.000003   hi def link htmlH3                      htmlH2
    1              0.000007   hi def link htmlH4                      htmlH3
    1              0.000002   hi def link htmlH5                      htmlH4
    1              0.000003   hi def link htmlH6                      htmlH5
    1              0.000003   hi def link htmlHead                    PreProc
    1              0.000010   hi def link htmlTitle                   Title
    1              0.000003   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlUnderlineBold           htmlBoldUnderline
    1              0.000003   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlItalicUnderline         htmlUnderlineItalic
    1              0.000003   hi def link htmlItalicBold              htmlBoldItalic
    1              0.000003   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlLink                    Underlined
    1              0.000003   hi def link htmlLeadingSpace            None
    1              0.000002   if !exists("html_my_rendering")
    1              0.000002     hi def htmlBold                term=bold cterm=bold gui=bold
    1              0.000002     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000002     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000002     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000002     hi def htmlUnderline           term=underline cterm=underline gui=underline
    1              0.000002     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000002     hi def htmlItalic              term=italic cterm=italic gui=italic
    1              0.000004     if v:version > 800 || v:version == 800 && has("patch1038")
    1              0.000002         hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
                                else
                                    hi def htmlStrike              term=underline cterm=underline gui=underline
    1              0.000001     endif
    1              0.000001   endif
    1              0.000000 endif
                            
    1              0.000003 hi def link htmlPreStmt            PreProc
    1              0.000007 hi def link htmlPreError           Error
    1              0.000004 hi def link htmlPreProc            PreProc
    1              0.000003 hi def link htmlPreAttr            String
    1              0.000003 hi def link htmlPreProcAttrName    PreProc
    1              0.000004 hi def link htmlPreProcAttrError   Error
    1              0.000002 hi def link htmlSpecial            Special
    1              0.000003 hi def link htmlSpecialChar        Special
    1              0.000004 hi def link htmlString             String
    1              0.000002 hi def link htmlStatement          Statement
    1              0.000003 hi def link htmlComment            Comment
    1              0.000004 hi def link htmlCommentPart        Comment
    1              0.000003 hi def link htmlValue              String
    1              0.000003 hi def link htmlCommentError       htmlError
    1              0.000003 hi def link htmlTagError           htmlError
    1              0.000004 hi def link htmlEvent              javaScript
    1              0.000003 hi def link htmlError              Error
                            
    1              0.000003 hi def link javaScript             Special
    1              0.000003 hi def link javaScriptExpression   javaScript
    1              0.000003 hi def link htmlCssStyleComment    Comment
    1              0.000003 hi def link htmlCssDefinition      Special
                            
    1              0.000003 let b:current_syntax = "html"
                            
    1              0.000002 if main_syntax == 'html'
                              unlet main_syntax
    1              0.000001 endif
                            
    1              0.000011 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/syntax/javascript.vim
Sourced 1 time
Total time:   0.000495
 Self time:   0.000495

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2019 Sep 27
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    1              0.000004 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
    1              0.000004 elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
    1              0.000001 endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
                            
    1              0.000007 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    1              0.000010 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    1              0.000008 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    1              0.000017 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    1              0.000005 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    1              0.000014 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000012 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000015 syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
    1              0.000008 syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
    1              0.000005 syn match   javaScriptSpecialCharacter "'\\.'"
    1              0.000008 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    1              0.000026 syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
    1              0.000004 syn keyword javaScriptConditional	if else switch
    1              0.000005 syn keyword javaScriptRepeat		while for do in
    1              0.000004 syn keyword javaScriptBranch		break continue
    1              0.000004 syn keyword javaScriptOperator		new delete instanceof typeof
    1              0.000006 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    1              0.000004 syn keyword javaScriptStatement		return with await
    1              0.000003 syn keyword javaScriptBoolean		true false
    1              0.000003 syn keyword javaScriptNull		null undefined
    1              0.000004 syn keyword javaScriptIdentifier	arguments this var let
    1              0.000003 syn keyword javaScriptLabel		case default
    1              0.000004 syn keyword javaScriptException		try catch finally throw
    1              0.000004 syn keyword javaScriptMessage		alert confirm prompt status
    1              0.000004 syn keyword javaScriptGlobal		self window top parent
    1              0.000004 syn keyword javaScriptMember		document event location 
    1              0.000004 syn keyword javaScriptDeprecated	escape unescape
    1              0.000015 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async
                            
    1              0.000019 syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
    1              0.000004 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
    1              0.000001 else
    1              0.000004     syn keyword javaScriptFunction	function
    1              0.000005     syn match	javaScriptBraces	   "[{}\[\]]"
    1              0.000004     syn match	javaScriptParens	   "[()]"
    1              0.000001 endif
                            
    1              0.000002 syn sync fromstart
    1              0.000001 syn sync maxlines=100
                            
    1              0.000003 if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    1              0.000005 hi def link javaScriptComment		Comment
    1              0.000004 hi def link javaScriptLineComment		Comment
    1              0.000004 hi def link javaScriptCommentTodo		Todo
    1              0.000004 hi def link javaScriptSpecial		Special
    1              0.000003 hi def link javaScriptStringS		String
    1              0.000004 hi def link javaScriptStringD		String
    1              0.000004 hi def link javaScriptStringT		String
    1              0.000003 hi def link javaScriptCharacter		Character
    1              0.000004 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    1              0.000007 hi def link javaScriptNumber		javaScriptValue
    1              0.000004 hi def link javaScriptConditional		Conditional
    1              0.000004 hi def link javaScriptRepeat		Repeat
    1              0.000004 hi def link javaScriptBranch		Conditional
    1              0.000003 hi def link javaScriptOperator		Operator
    1              0.000004 hi def link javaScriptType			Type
    1              0.000004 hi def link javaScriptStatement		Statement
    1              0.000003 hi def link javaScriptFunction		Function
    1              0.000004 hi def link javaScriptBraces		Function
    1              0.000003 hi def link javaScriptError		Error
    1              0.000003 hi def link javaScrParenError		javaScriptError
    1              0.000004 hi def link javaScriptNull			Keyword
    1              0.000003 hi def link javaScriptBoolean		Boolean
    1              0.000004 hi def link javaScriptRegexpString		String
                            
    1              0.000004 hi def link javaScriptIdentifier		Identifier
    1              0.000004 hi def link javaScriptLabel		Label
    1              0.000003 hi def link javaScriptException		Exception
    1              0.000004 hi def link javaScriptMessage		Keyword
    1              0.000003 hi def link javaScriptGlobal		Keyword
    1              0.000004 hi def link javaScriptMember		Keyword
    1              0.000003 hi def link javaScriptDeprecated		Exception 
    1              0.000004 hi def link javaScriptReserved		Keyword
    1              0.000003 hi def link javaScriptDebug		Debug
    1              0.000004 hi def link javaScriptConstant		Label
    1              0.000003 hi def link javaScriptEmbed		Special
                            
                            
                            
    1              0.000003 let b:current_syntax = "javascript"
    1              0.000002 if main_syntax == 'javascript'
                              unlet main_syntax
    1              0.000005 endif
    1              0.000008 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/syntax/vb.vim
Sourced 1 time
Total time:   0.003250
 Self time:   0.003250

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    1              0.000005 if exists("b:current_syntax")
                            	finish
    1              0.000001 endif
                            
                            " VB is case insensitive
    1              0.000001 syn case ignore
                            
    1              0.000006 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    1              0.000005 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    1              0.000005 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    1              0.000006 syn match vbOperator "[()+.,\-/*=&]"
    1              0.000004 syn match vbOperator "[<>]=\="
    1              0.000004 syn match vbOperator "<>"
    1              0.000005 syn match vbOperator "\s\+_$"
                            
    1              0.000004 syn keyword vbBoolean  True False
    1              0.000003 syn keyword vbConst Null Nothing
                            
    1              0.000004 syn keyword vbRepeat Do For ForEach Loop Next
    1              0.000005 syn keyword vbRepeat Step To Until Wend While
                            
    1              0.000004 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    1              0.000004 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    1              0.000004 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    1              0.000004 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    1              0.000003 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    1              0.000004 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    1              0.000004 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    1              0.000003 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    1              0.000008 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    1              0.000003 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    1              0.000004 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    1              0.000004 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    1              0.000003 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    1              0.000004 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    1              0.000003 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    1              0.000005 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    1              0.000004 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    1              0.000004 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    1              0.000004 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    1              0.000004 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    1              0.000004 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    1              0.000004 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    1              0.000003 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    1              0.000004 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    1              0.000004 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    1              0.000004 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    1              0.000004 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    1              0.000004 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    1              0.000003 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    1              0.000004 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    1              0.000004 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    1              0.000005 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    1              0.000004 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    1              0.000004 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    1              0.000004 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    1              0.000004 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    1              0.000004 syn keyword vbEvents IniProperties InitProperties Initialize
    1              0.000003 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    1              0.000003 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    1              0.000004 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    1              0.000008 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    1              0.000004 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    1              0.000004 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    1              0.000004 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    1              0.000004 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    1              0.000008 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    1              0.000004 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    1              0.000004 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    1              0.000004 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    1              0.000004 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    1              0.000004 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    1              0.000004 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    1              0.000004 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    1              0.000003 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    1              0.000004 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    1              0.000003 syn keyword vbEvents RepeatedControlUnloaded Reposition
    1              0.000003 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    1              0.000004 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    1              0.000004 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    1              0.000004 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    1              0.000004 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    1              0.000004 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    1              0.000005 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    1              0.000004 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    1              0.000004 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    1              0.000003 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    1              0.000004 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    1              0.000004 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    1              0.000003 syn keyword vbEvents UserEvent Validate ValidationError
    1              0.000004 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    1              0.000004 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    1              0.000003 syn keyword vbEvents WriteProperties
                            
                            
    1              0.000006 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    1              0.000006 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    1              0.000005 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    1              0.000005 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    1              0.000005 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    1              0.000005 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    1              0.000004 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    1              0.000004 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    1              0.000004 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    1              0.000004 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    1              0.000004 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    1              0.000005 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    1              0.000004 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    1              0.000093 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    1              0.000054 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    1              0.000063 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    1              0.000345 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    1              0.000103 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    1              0.000140 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    1              0.000080 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    1              0.000046 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    1              0.000055 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    1              0.000065 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    1              0.000015 syn keyword vbFunction Year
                            
    1              0.000045 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    1              0.000034 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    1              0.000045 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    1              0.000034 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    1              0.000053 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    1              0.000044 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    1              0.000034 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    1              0.000045 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    1              0.000044 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    1              0.000044 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    1              0.000036 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    1              0.000053 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    1              0.000035 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    1              0.000035 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    1              0.000045 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    1              0.000034 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    1              0.000035 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    1              0.000034 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    1              0.000036 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    1              0.000036 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    1              0.000025 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    1              0.000006 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    1              0.000005 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    1              0.000004 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    1              0.000005 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    1              0.000004 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    1              0.000005 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    1              0.000004 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    1              0.000004 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    1              0.000004 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    1              0.000004 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    1              0.000004 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    1              0.000004 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    1              0.000004 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    1              0.000004 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    1              0.000005 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    1              0.000004 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    1              0.000008 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    1              0.000005 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    1              0.000004 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    1              0.000005 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    1              0.000004 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    1              0.000004 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    1              0.000004 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    1              0.000004 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    1              0.000004 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    1              0.000004 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    1              0.000004 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    1              0.000005 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    1              0.000004 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    1              0.000004 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    1              0.000004 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    1              0.000004 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    1              0.000004 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    1              0.000004 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    1              0.000004 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    1              0.000004 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    1              0.000006 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    1              0.000082 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    1              0.000008 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    1              0.000004 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    1              0.000005 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    1              0.000005 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    1              0.000005 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    1              0.000004 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    1              0.000005 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    1              0.000004 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    1              0.000005 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    1              0.000004 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    1              0.000011 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    1              0.000004 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    1              0.000004 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    1              0.000010 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    1              0.000004 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    1              0.000004 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    1              0.000003 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    1              0.000005 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    1              0.000006 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    1              0.000005 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    1              0.000005 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    1              0.000006 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    1              0.000005 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    1              0.000005 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    1              0.000006 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    1              0.000005 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    1              0.000004 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    1              0.000005 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    1              0.000005 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    1              0.000005 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    1              0.000002 syn keyword vbStatement Write
                            
    1              0.000005 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    1              0.000005 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    1              0.000005 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    1              0.000004 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    1              0.000005 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    1              0.000004 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    1              0.000003 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
    1              0.000005 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    1              0.000005 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    1              0.000005 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    1              0.000004 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    1              0.000005 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    1              0.000004 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    1              0.000003 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    1              0.000004 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    1              0.000004 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    1              0.000004 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    1              0.000003 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    1              0.000004 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    1              0.000005 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    1              0.000003 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    1              0.000004 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    1              0.000004 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    1              0.000004 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    1              0.000004 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    1              0.000004 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    1              0.000004 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    1              0.000003 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    1              0.000004 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    1              0.000005 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    1              0.000004 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    1              0.000003 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    1              0.000004 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    1              0.000004 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    1              0.000007 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    1              0.000003 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    1              0.000004 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    1              0.000004 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    1              0.000004 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    1              0.000004 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    1              0.000004 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    1              0.000004 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    1              0.000004 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    1              0.000007 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    1              0.000004 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    1              0.000004 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    1              0.000004 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    1              0.000005 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    1              0.000004 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    1              0.000004 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    1              0.000004 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    1              0.000004 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    1              0.000003 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    1              0.000004 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    1              0.000003 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    1              0.000004 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    1              0.000004 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    1              0.000004 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    1              0.000004 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    1              0.000004 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    1              0.000004 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    1              0.000004 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    1              0.000004 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    1              0.000003 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    1              0.000004 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    1              0.000004 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    1              0.000007 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    1              0.000004 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    1              0.000003 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    1              0.000003 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    1              0.000005 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    1              0.000004 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    1              0.000004 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    1              0.000004 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    1              0.000004 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    1              0.000004 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    1              0.000004 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    1              0.000003 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    1              0.000008 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    1              0.000006 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    1              0.000004 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
    1              0.000007 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
    1              0.000007 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    1              0.000005 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
    1              0.000008 syn region  vbString		start=+"+  end=+"\|$+
    1              0.000011 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    1              0.000009 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    1              0.000005 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
    1              0.000010 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
    1              0.000005 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000006 hi def link vbBoolean		Boolean
    1              0.000004 hi def link vbLineNumber		Comment
    1              0.000003 hi def link vbComment		Comment
    1              0.000004 hi def link vbConditional	Conditional
    1              0.000004 hi def link vbConst			Constant
    1              0.000003 hi def link vbDefine			Constant
    1              0.000003 hi def link vbError			Error
    1              0.000004 hi def link vbFunction		Identifier
    1              0.000003 hi def link vbIdentifier		Identifier
    1              0.000004 hi def link vbNumber			Number
    1              0.000003 hi def link vbFloat			Float
    1              0.000003 hi def link vbMethods		PreProc
    1              0.000004 hi def link vbOperator		Operator
    1              0.000003 hi def link vbRepeat			Repeat
    1              0.000003 hi def link vbString			String
    1              0.000004 hi def link vbStatement		Statement
    1              0.000004 hi def link vbKeyword		Statement
    1              0.000003 hi def link vbEvents			Special
    1              0.000003 hi def link vbTodo			Todo
    1              0.000003 hi def link vbTypes			Type
    1              0.000003 hi def link vbTypeSpecifier	Type
                            
                            
    1              0.000006 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/syntax/css.vim
Sourced 1 time
Total time:   0.014876
 Self time:   0.014876

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/JulesWang/css.vim
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " Last Change:  2019 Jul. 29
                            
                            " quit when a syntax file was already loaded
    1              0.000006 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
    1              0.000004 elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
    1              0.000001 endif
                            
    1              0.000007 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000001 syn case ignore
                            
                            " HTML4 tags
    1              0.000006 syn keyword cssTagName abbr address area a b base
    1              0.000005 syn keyword cssTagName bdo blockquote body br button
    1              0.000006 syn keyword cssTagName caption cite code col colgroup dd del
    1              0.000004 syn keyword cssTagName dfn div dl dt em fieldset form
    1              0.000005 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    1              0.000005 syn keyword cssTagName iframe input ins isindex kbd label legend li
    1              0.000004 syn keyword cssTagName link map menu meta noscript ol optgroup
    1              0.000005 syn keyword cssTagName option p param pre q s samp script small
    1              0.000004 syn keyword cssTagName span strong sub sup tbody td
    1              0.000005 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    1              0.000003 syn keyword cssTagName object svg
    1              0.000007 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    1              0.000005 syn keyword cssTagName article aside audio bdi canvas command data
    1              0.000006 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    1              0.000004 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    1              0.000005 syn keyword cssTagName output progress rt rp ruby section
    1              0.000004 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    1              0.000005 syn match cssTagName "\*"
                            
                            " selectors
    1              0.000005 syn match cssSelectorOp "[,>+~]"
    1              0.000008 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    1              0.000019 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    1              0.000009 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    1              0.000004 syn match cssClassNameDot contained '\.'
                            
    1              0.000002 try
    1              0.000006 syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
    1              0.000001 endtry
                            
                            " digits
    1              0.000007 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    1              0.000008 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    1              0.000011 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\)\>" contains=cssUnitDecorators
    1              0.000007 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    1              0.000008 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    1              0.000008 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    1              0.000007 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    1              0.000008 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    1              0.000003 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    1              0.000004 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    1              0.000006 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    1              0.000006 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    1              0.000007 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    1              0.000005 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    1              0.000009 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    1              0.000005 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    1              0.000007 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    1              0.000004 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    1              0.000005 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    1              0.000003 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    1              0.000007 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    1              0.000006 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    1              0.000005 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    1              0.000006 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    1              0.000005 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    1              0.000003 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    1              0.000004 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    1              0.000006 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    1              0.000004 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    1              0.000004 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    1              0.000004 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    1              0.000005 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    1              0.000004 syn keyword cssColor contained thistle tomato turquoise violet wheat
    1              0.000003 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    1              0.000002 syn case match
    1              0.000010 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    1              0.000001 syn case ignore
                            
    1              0.000004 syn match cssImportant contained "!\s*important\>"
    1              0.000004 syn match cssCustomProp contained "--[a-zA-Z0-9-_]*"
                            
    1              0.000004 syn match cssColor contained "\<transparent\>"
    1              0.000008 syn match cssColor contained "\<currentColor\>"
    1              0.000003 syn match cssColor contained "\<white\>"
    1              0.000007 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    1              0.000039 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    1              0.000007 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    1              0.000015 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    1              0.000607 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    1              0.000021 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    1              0.000023 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    1              0.000025 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    1              0.000025 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000006 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    1              0.000003 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    1              0.000005 syn keyword cssCommonAttr contained auto none inherit all default normal
    1              0.000004 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    1              0.000010 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    1              0.000003 syn keyword cssAnimationAttr contained alternate reverse
    1              0.000005 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    1              0.000004 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    1              0.000002 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    1              0.000006 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    1              0.000007 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    1              0.000003 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    1              0.000004 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    1              0.000003 syn match cssBackgroundAttr contained "\<no-repeat\>"
    1              0.000005 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    1              0.000003 syn keyword cssBackgroundAttr contained cover contain
                            
    1              0.000007 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    1              0.000006 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    1              0.000006 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    1              0.000004 syn match cssBorderProp contained "\<box-decoration-break\>"
    1              0.000004 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    1              0.000003 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    1              0.000005 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    1              0.000003 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    1              0.000003 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    1              0.000005 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000005 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000005 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    1              0.000004 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    1              0.000003 syn keyword cssBoxAttr contained visible hidden scroll auto
    1              0.000004 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    1              0.000002 syn keyword cssCascadeProp contained all
    1              0.000003 syn keyword cssCascadeAttr contained initial unset revert
                            
    1              0.000002 syn keyword cssColorProp contained opacity
    1              0.000004 syn match cssColorProp contained "\<color-profile\>"
    1              0.000004 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    1              0.000005 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    1              0.000002 syn keyword cssDimensionProp contained height
    1              0.000002 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    1              0.000006 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    1              0.000005 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    1              0.000003 syn keyword cssFlexibleBoxProp contained order
                            
    1              0.000009 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    1              0.000004 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    1              0.000004 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    1              0.000005 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    1              0.000014 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    1              0.000003 syn keyword cssFontAttr contained icon menu caption
    1              0.000003 syn match cssFontAttr contained "\<message-box\>"
    1              0.000007 syn match cssFontAttr contained "\<status-bar\>"
    1              0.000003 syn keyword cssFontAttr contained larger smaller
    1              0.000005 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    1              0.000004 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    1              0.000004 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    1              0.000013 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    1              0.000003 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    1              0.000003 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    1              0.000006 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    1              0.000002 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    1              0.000002 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    1              0.000003 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    1              0.000004 syn match cssFontProp contained "\<font-smooth\>"
    1              0.000005 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    1              0.000005 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    1              0.000007 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    1              0.000003 syn keyword cssMultiColumnProp contained columns
    1              0.000002 syn keyword cssMultiColumnAttr contained balance medium
    1              0.000004 syn keyword cssMultiColumnAttr contained always left right page column
    1              0.000005 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    1              0.000006 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    1              0.000004 syn match cssInteractProp contained "\<pointer-events\>"
    1              0.000005 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    1              0.000003 syn keyword cssGeneratedContentProp contained quotes crop
    1              0.000004 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    1              0.000004 syn match cssGeneratedContentProp contained "\<move-to\>"
    1              0.000004 syn match cssGeneratedContentProp contained "\<page-policy\>"
    1              0.000004 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    1              0.000004 syn match cssGridProp contained "\<grid\>"
    1              0.000005 syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
    1              0.000009 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    1              0.000004 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    1              0.000005 syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
    1              0.000005 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    1              0.000004 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    1              0.000006 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    1              0.000004 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    1              0.000005 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    1              0.000004 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    1              0.000003 syn keyword cssListAttr contained inside outside
                            
    1              0.000004 syn keyword cssPositioningProp contained bottom clear clip display float left
    1              0.000006 syn keyword cssPositioningProp contained position right top visibility
    1              0.000004 syn match cssPositioningProp contained "\<z-index\>"
    1              0.000003 syn keyword cssPositioningAttr contained block compact grid
    1              0.000021 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    1              0.000002 syn keyword cssPositioningAttr contained left right both
    1              0.000003 syn match cssPositioningAttr contained "\<list-item\>"
    1              0.000004 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    1              0.000004 syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
    1              0.000003 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid
                            
    1              0.000003 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    1              0.000006 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    1              0.000004 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    1              0.000003 syn keyword cssTextProp contained color direction hyphens
    1              0.000009 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    1              0.000009 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    1              0.000005 syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
    1              0.000003 syn match cssTextProp contained "\<white-space\>"
    1              0.000004 syn match cssTextProp contained "\<hanging-punctuation\>"
    1              0.000003 syn match cssTextProp contained "\<tab-size\>"
    1              0.000003 syn match cssTextProp contained "\<punctuation-trim\>"
    1              0.000003 syn match cssTextAttr contained "\<line-through\>"
    1              0.000004 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    1              0.000003 syn keyword cssTextAttr contained ltr rtl embed nowrap
    1              0.000004 syn keyword cssTextAttr contained underline overline blink sub super middle
    1              0.000003 syn keyword cssTextAttr contained capitalize uppercase lowercase
    1              0.000002 syn keyword cssTextAttr contained justify baseline sub super
    1              0.000004 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
    1              0.000003 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    1              0.000004 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    1              0.000002 syn keyword cssTextAttr contained start end adjacent
    1              0.000004 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    1              0.000003 syn keyword cssTextAttr contained distribute kashida first last
    1              0.000003 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    1              0.000003 syn match cssTextAttr contained "\<break-all\>"
    1              0.000003 syn match cssTextAttr contained "\<break-word\>"
    1              0.000002 syn keyword cssTextAttr contained manual
    1              0.000003 syn match cssTextAttr contained "\<bidi-override\>"
                            
    1              0.000003 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    1              0.000003 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    1              0.000004 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    1              0.000005 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    1              0.000004 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    1              0.000004 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    1              0.000003 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    1              0.000003 syn match cssUIProp contained "\<box-sizing\>"
    1              0.000005 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    1              0.000002 syn keyword cssUIProp contained cursor
    1              0.000005 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    1              0.000004 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    1              0.000003 syn keyword cssUIAttr contained progress wait text cell move
    1              0.000003 syn match cssUIAttr contained "\<context-menu\>"
    1              0.000003 syn match cssUIAttr contained "\<no-drop\>"
    1              0.000003 syn match cssUIAttr contained "\<not-allowed\>"
    1              0.000003 syn match cssUIAttr contained "\<all-scroll\>"
    1              0.000003 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    1              0.000003 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    1              0.000003 syn match cssUIProp contained "\<ime-mode\>"
    1              0.000002 syn keyword cssUIAttr contained active inactive disabled
                            
    1              0.000004 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    1              0.000004 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    1              0.000002 syn keyword cssUIAttr contained invert
                            
    1              0.000002 syn keyword cssUIProp contained icon resize
    1              0.000002 syn keyword cssUIAttr contained both horizontal vertical
                            
    1              0.000003 syn match cssUIProp contained "\<text-overflow\>"
    1              0.000005 syn keyword cssUIAttr contained clip ellipsis
                            
    1              0.000003 syn match cssUIProp contained "\<image-rendering\>"
    1              0.000002 syn keyword cssUIAttr contained pixellated
    1              0.000003 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    1              0.000003 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    1              0.000013 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    1              0.000006 syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
    1              0.000004 syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
    1              0.000002 syn keyword cssUIProp contained appearance
    1              0.000003 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    1              0.000005 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    1              0.000007 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    1              0.000004 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    1              0.000004 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    1              0.000002 syn keyword cssAuralAttr contained silent
    1              0.000003 syn match cssAuralAttr contained "\<spell-out\>"
    1              0.000002 syn keyword cssAuralAttr contained non mix
    1              0.000004 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    1              0.000004 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    1              0.000002 syn keyword cssAuralAttr contained leftwards rightwards behind
    1              0.000007 syn keyword cssAuralAttr contained below level above lower higher
    1              0.000004 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    1              0.000002 syn keyword cssAuralAttr contained faster slower
    1              0.000004 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    1              0.000003 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    1              0.000002 syn keyword cssMediaProp contained width height orientation scan
    1              0.000004 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    1              0.000004 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    1              0.000005 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    1              0.000006 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    1              0.000003 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    1              0.000007 syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
    1              0.000008 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    1              0.000002 syn keyword cssPageProp contained content size
    1              0.000002 syn keyword cssPageProp contained orphans widows
    1              0.000002 syn keyword cssFontDescriptorProp contained src
    1              0.000004 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    1              0.000004 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    1              0.000003 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    1              0.000002 syn match cssBraces contained "[{}]"
    1              0.000003 syn match cssError contained "{@<>"
    1              0.002114 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    1              0.000008 syn match cssBraceError "}"
    1              0.000003 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    1              0.000014 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    1              0.000005 syn keyword cssPseudoClassId contained link visited active hover before after left right
    1              0.000004 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    1              0.000005 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    1              0.000005 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    1              0.000014 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ
                            " ------------------------------------
                            " Vendor specific properties
    1              0.000003 syn match cssPseudoClassId contained  "\<selection\>"
    1              0.000004 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    1              0.000004 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    1              0.000010 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    1              0.000004 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    1              0.000007 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    1              0.000005 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    1              0.000004 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    1              0.000006 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    1              0.000012 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    1              0.000010 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    1              0.000004 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    1              0.000003 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
    1              0.002753 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    1              0.004401 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    1              0.000070 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
    1              0.000008 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    1              0.000046 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
    1              0.000011 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    1              0.000184 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    1              0.000014 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    1              0.000032 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    1              0.000031 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    1              0.000016 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    1              0.000016 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    1              0.002354 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    1              0.000021 if main_syntax == "css"
                              syn sync minlines=10
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000006 hi def link cssComment Comment
    1              0.000003 hi def link cssVendor Comment
    1              0.000003 hi def link cssHacks Comment
    1              0.000003 hi def link cssTagName Statement
    1              0.000019 hi def link cssDeprecated Error
    1              0.000008 hi def link cssSelectorOp Special
    1              0.000005 hi def link cssSelectorOp2 Special
    1              0.000005 hi def link cssAttrComma Special
                            
    1              0.000004 hi def link cssAnimationProp cssProp
    1              0.000003 hi def link cssBackgroundProp cssProp
    1              0.000015 hi def link cssBorderProp cssProp
    1              0.000003 hi def link cssBoxProp cssProp
    1              0.000003 hi def link cssCascadeProp cssProp
    1              0.000003 hi def link cssColorProp cssProp
    1              0.000014 hi def link cssContentForPagedMediaProp cssProp
    1              0.000006 hi def link cssDimensionProp cssProp
    1              0.000008 hi def link cssFlexibleBoxProp cssProp
    1              0.000022 hi def link cssFontProp cssProp
    1              0.000005 hi def link cssGeneratedContentProp cssProp
    1              0.000003 hi def link cssGridProp cssProp
    1              0.000003 hi def link cssHyerlinkProp cssProp
    1              0.000004 hi def link cssInteractProp cssProp
    1              0.000003 hi def link cssLineboxProp cssProp
    1              0.000003 hi def link cssListProp cssProp
    1              0.000003 hi def link cssMarqueeProp cssProp
    1              0.000004 hi def link cssMultiColumnProp cssProp
    1              0.000003 hi def link cssPagedMediaProp cssProp
    1              0.000003 hi def link cssPositioningProp cssProp
    1              0.000003 hi def link cssPrintProp cssProp
    1              0.000003 hi def link cssRubyProp cssProp
    1              0.000003 hi def link cssSpeechProp cssProp
    1              0.000003 hi def link cssTableProp cssProp
    1              0.000003 hi def link cssTextProp cssProp
    1              0.000003 hi def link cssTransformProp cssProp
    1              0.000003 hi def link cssTransitionProp cssProp
    1              0.000004 hi def link cssUIProp cssProp
    1              0.000002 hi def link cssIEUIProp cssProp
    1              0.000003 hi def link cssAuralProp cssProp
    1              0.000003 hi def link cssRenderProp cssProp
    1              0.000003 hi def link cssMobileTextProp cssProp
                            
    1              0.000003 hi def link cssAnimationAttr cssAttr
    1              0.000003 hi def link cssBackgroundAttr cssAttr
    1              0.000003 hi def link cssBorderAttr cssAttr
    1              0.000003 hi def link cssBoxAttr cssAttr
    1              0.000003 hi def link cssContentForPagedMediaAttr cssAttr
    1              0.000002 hi def link cssDimensionAttr cssAttr
    1              0.000004 hi def link cssFlexibleBoxAttr cssAttr
    1              0.000009 hi def link cssFontAttr cssAttr
    1              0.000004 hi def link cssGeneratedContentAttr cssAttr
    1              0.000002 hi def link cssGridAttr cssAttr
    1              0.000002 hi def link cssHyerlinkAttr cssAttr
    1              0.000002 hi def link cssInteractAttr cssAttr
    1              0.000002 hi def link cssLineboxAttr cssAttr
    1              0.000002 hi def link cssListAttr cssAttr
    1              0.000001 hi def link cssMarginAttr cssAttr
    1              0.000002 hi def link cssMarqueeAttr cssAttr
    1              0.000002 hi def link cssMultiColumnAttr cssAttr
    1              0.000002 hi def link cssPaddingAttr cssAttr
    1              0.000002 hi def link cssPagedMediaAttr cssAttr
    1              0.000001 hi def link cssPositioningAttr cssAttr
    1              0.000002 hi def link cssGradientAttr cssAttr
    1              0.000002 hi def link cssPrintAttr cssAttr
    1              0.000001 hi def link cssRubyAttr cssAttr
    1              0.000002 hi def link cssSpeechAttr cssAttr
    1              0.000002 hi def link cssTableAttr cssAttr
    1              0.000002 hi def link cssTextAttr cssAttr
    1              0.000001 hi def link cssTransformAttr cssAttr
    1              0.000002 hi def link cssTransitionAttr cssAttr
    1              0.000002 hi def link cssUIAttr cssAttr
    1              0.000002 hi def link cssIEUIAttr cssAttr
    1              0.000002 hi def link cssAuralAttr cssAttr
    1              0.000002 hi def link cssRenderAttr cssAttr
    1              0.000002 hi def link cssCascadeAttr cssAttr
    1              0.000002 hi def link cssCommonAttr cssAttr
                            
    1              0.000004 hi def link cssPseudoClassId PreProc
    1              0.000003 hi def link cssPseudoClassLang Constant
    1              0.000003 hi def link cssValueLength Number
    1              0.000003 hi def link cssValueInteger Number
    1              0.000006 hi def link cssValueNumber Number
    1              0.000003 hi def link cssValueAngle Number
    1              0.000002 hi def link cssValueTime Number
    1              0.000004 hi def link cssValueFrequency Number
    1              0.000003 hi def link cssFunction Constant
    1              0.000003 hi def link cssURL String
    1              0.000003 hi def link cssFunctionName Function
    1              0.000003 hi def link cssFunctionComma Function
    1              0.000003 hi def link cssColor Constant
    1              0.000003 hi def link cssIdentifier Function
    1              0.000002 hi def link cssAtRule Include
    1              0.000019 hi def link cssAtKeyword PreProc
    1              0.000006 hi def link cssImportant Special
    1              0.000005 hi def link cssCustomProp Special
    1              0.000005 hi def link cssBraces Function
    1              0.000003 hi def link cssBraceError Error
    1              0.000003 hi def link cssError Error
    1              0.000004 hi def link cssUnicodeEscape Special
    1              0.000004 hi def link cssStringQQ String
    1              0.000015 hi def link cssStringQ String
    1              0.000005 hi def link cssAttributeSelector String
    1              0.000003 hi def link cssMediaType Special
    1              0.000003 hi def link cssMediaComma Normal
    1              0.000003 hi def link cssAtRuleLogical Statement
    1              0.000002 hi def link cssMediaProp cssProp
    1              0.000002 hi def link cssMediaAttr cssAttr
    1              0.000002 hi def link cssPagePseudo PreProc
    1              0.000002 hi def link cssPageMarginProp cssAtKeyword
    1              0.000002 hi def link cssPageProp cssProp
    1              0.000019 hi def link cssKeyFrameProp Constant
    1              0.000003 hi def link cssFontDescriptor Special
    1              0.000002 hi def link cssFontDescriptorProp cssProp
    1              0.000007 hi def link cssFontDescriptorAttr cssAttr
    1              0.000003 hi def link cssUnicodeRange Constant
    1              0.000002 hi def link cssClassName Function
    1              0.000003 hi def link cssClassNameDot Function
    1              0.000003 hi def link cssProp StorageClass
    1              0.000002 hi def link cssAttr Constant
    1              0.000003 hi def link cssUnitDecorators Number
    1              0.000002 hi def link cssNoise Noise
                            
    1              0.000005 let b:current_syntax = "css"
                            
    1              0.000003 if main_syntax == 'css'
                              unlet main_syntax
    1              0.000001 endif
                            
    1              0.000014 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/ftplugin/markdown.vim
Sourced 1 time
Total time:   0.001110
 Self time:   0.000863

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Markdown
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:		2019 Dec 05
                            
    1              0.000004 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
    1   0.001003   0.000756 runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
                            
    1              0.000009 setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=<!--%s-->
    1              0.000009 setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
    1              0.000004 setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:
                            
    1              0.000005 if exists('b:undo_ftplugin')
    1              0.000004   let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
                            else
                              let b:undo_ftplugin = "setl cms< com< fo< flp<"
    1              0.000000 endif
                            
    1              0.000003 function! s:NotCodeBlock(lnum) abort
                              return synIDattr(synID(v:lnum, 1, 1), 'name') !=# 'markdownCode'
                            endfunction
                            
    1              0.000002 function! MarkdownFold() abort
                              let line = getline(v:lnum)
                            
                              if line =~# '^#\+ ' && s:NotCodeBlock(v:lnum)
                                return ">" . match(line, ' ')
                              endif
                            
                              let nextline = getline(v:lnum + 1)
                              if (line =~ '^.\+$') && (nextline =~ '^=\+$') && s:NotCodeBlock(v:lnum + 1)
                                return ">1"
                              endif
                            
                              if (line =~ '^.\+$') && (nextline =~ '^-\+$') && s:NotCodeBlock(v:lnum + 1)
                                return ">2"
                              endif
                            
                              return "="
                            endfunction
                            
    1              0.000002 function! s:HashIndent(lnum) abort
                              let hash_header = matchstr(getline(a:lnum), '^#\{1,6}')
                              if len(hash_header)
                                return hash_header
                              else
                                let nextline = getline(a:lnum + 1)
                                if nextline =~# '^=\+\s*$'
                                  return '#'
                                elseif nextline =~# '^-\+\s*$'
                                  return '##'
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! MarkdownFoldText() abort
                              let hash_indent = s:HashIndent(v:foldstart)
                              let title = substitute(getline(v:foldstart), '^#\+\s*', '', '')
                              let foldsize = (v:foldend - v:foldstart + 1)
                              let linecount = '['.foldsize.' lines]'
                              return hash_indent.' '.title.' '.linecount
                            endfunction
                            
    1              0.000004 if has("folding") && exists("g:markdown_folding")
                              setlocal foldexpr=MarkdownFold()
                              setlocal foldmethod=expr
                              setlocal foldtext=MarkdownFoldText()
                              let b:undo_ftplugin .= " foldexpr< foldmethod< foldtext<"
    1              0.000001 endif
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/ftplugin/html.vim
Sourced 1 time
Total time:   0.000225
 Self time:   0.000107

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    1              0.000005 if exists("b:did_ftplugin") | finish | endif
    1              0.000002 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    1              0.000003 let s:save_cpo = &cpo
    1              0.000008 set cpo-=C
                            
    1              0.000005 setlocal matchpairs+=<:>
    1              0.000003 setlocal commentstring=<!--%s-->
    1              0.000004 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    1              0.000004 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
    1              0.000000 endif
                            
    1              0.000002 if exists('&omnifunc')
    1              0.000003   setlocal omnifunc=htmlcomplete#CompleteTags
    1   0.000135   0.000017   call htmlcomplete#DetectOmniFlavor()
    1              0.000001 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
    1              0.000002 if exists("loaded_matchit")
                                let b:match_ignorecase = 1
                                let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    1              0.000000 endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    1              0.000003 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
                            " Undo the stuff we changed.
    1              0.000004 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    1              0.000007 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /Users/tatsuro/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim
Sourced 1 time
Total time:   0.009446
 Self time:   0.009398

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp.vim
                            " Description:   Fuzzy file, buffer, mru, tag, etc finder.
                            " Author:        CtrlP Dev Team
                            " Original:      Kien Nguyen <github.com/kien>
                            " Version:       1.80
                            " =============================================================================
                            
                            " ** Static variables {{{1
                            " s:ignore() {{{2
    1              0.000019 fu! s:ignore()
                            	let igdirs = [
                            		\ '\.git',
                            		\ '\.hg',
                            		\ '\.svn',
                            		\ '_darcs',
                            		\ '\.bzr',
                            		\ '\.cdv',
                            		\ '\~\.dep',
                            		\ '\~\.dot',
                            		\ '\~\.nib',
                            		\ '\~\.plst',
                            		\ '\.pc',
                            		\ '_MTN',
                            		\ 'blib',
                            		\ 'CVS',
                            		\ 'RCS',
                            		\ 'SCCS',
                            		\ '_sgbak',
                            		\ 'autom4te\.cache',
                            		\ 'cover_db',
                            		\ '_build',
                            		\ ]
                            	let igfiles = [
                            		\ '\~$',
                            		\ '#.+#$',
                            		\ '[._].*\.swp$',
                            		\ 'core\.\d+$',
                            		\ '\.exe$',
                            		\ '\.so$',
                            		\ '\.bak$',
                            		\ '\.png$',
                            		\ '\.jpg$',
                            		\ '\.gif$',
                            		\ '\.zip$',
                            		\ '\.rar$',
                            		\ '\.tar\.gz$',
                            		\ ]
                            	retu {
                            		\ 'dir': '\v[\/]('.join(igdirs, '|').')$',
                            		\ 'file': '\v'.join(igfiles, '|'),
                            		\ }
                            endf
                            " Script local vars {{{2
    1   0.000221   0.000173 let [s:pref, s:bpref, s:opts, s:new_opts, s:lc_opts] =
                            	\ ['g:ctrlp_', 'b:ctrlp_', {
                            	\ 'abbrev':                ['s:abbrev', {}],
                            	\ 'arg_map':               ['s:argmap', 0],
                            	\ 'buffer_func':           ['s:buffunc', {}],
                            	\ 'by_filename':           ['s:byfname', 0],
                            	\ 'custom_ignore':         ['s:usrign', s:ignore()],
                            	\ 'default_input':         ['s:deftxt', 0],
                            	\ 'dont_split':            ['s:nosplit', 'netrw'],
                            	\ 'dotfiles':              ['s:showhidden', 0],
                            	\ 'extensions':            ['s:extensions', []],
                            	\ 'follow_symlinks':       ['s:folsym', 0],
                            	\ 'highlight_match':       ['s:mathi', [1, 'CtrlPMatch']],
                            	\ 'jump_to_buffer':        ['s:jmptobuf', 'Et'],
                            	\ 'key_loop':              ['s:keyloop', 0],
                            	\ 'lazy_update':           ['s:lazy', 0],
                            	\ 'match_func':            ['s:matcher', {}],
                            	\ 'match_window':          ['s:mw', ''],
                            	\ 'match_window_bottom':   ['s:mwbottom', 1],
                            	\ 'match_window_reversed': ['s:mwreverse', 1],
                            	\ 'max_depth':             ['s:maxdepth', 40],
                            	\ 'max_files':             ['s:maxfiles', 10000],
                            	\ 'max_height':            ['s:mxheight', 10],
                            	\ 'max_history':           ['s:maxhst', exists('+hi') ? &hi : 20],
                            	\ 'mruf_default_order':    ['s:mrudef', 0],
                            	\ 'open_func':             ['s:openfunc', {}],
                            	\ 'open_multi':            ['s:opmul', '1v'],
                            	\ 'open_new_file':         ['s:newfop', 'v'],
                            	\ 'prompt_mappings':       ['s:urprtmaps', 0],
                            	\ 'regexp_search':         ['s:regexp', 0],
                            	\ 'root_markers':          ['s:rmarkers', []],
                            	\ 'split_window':          ['s:splitwin', 0],
                            	\ 'status_func':           ['s:status', {}],
                            	\ 'tabpage_position':      ['s:tabpage', 'ac'],
                            	\ 'use_caching':           ['s:caching', 1],
                            	\ 'user_command':          ['s:usrcmd', ''],
                            	\ 'validate':              ['s:validate', ''],
                            	\ 'working_path_mode':     ['s:pathmode', 'ra'],
                            	\ 'line_prefix':           ['s:lineprefix', '> '],
                            	\ 'open_single_match':     ['s:opensingle', []],
                            	\ 'brief_prompt':          ['s:brfprt', 0],
                            	\ 'match_current_file':    ['s:matchcrfile', 0],
                            	\ 'match_natural_name':    ['s:matchnatural', 0],
                            	\ 'compare_lim':           ['s:compare_lim', 3000],
                            	\ 'bufname_mod':           ['s:bufname_mod', ':t'],
                            	\ 'bufpath_mod':           ['s:bufpath_mod', ':~:.:h'],
                            	\ 'formatline_func':       ['s:flfunc', 's:formatline(v:val)'],
                            	\ 'user_command_async':    ['s:usrcmdasync', 0],
                            	\ }, {
                            	\ 'open_multiple_files':   's:opmul',
                            	\ 'regexp':                's:regexp',
                            	\ 'reuse_window':          's:nosplit',
                            	\ 'show_hidden':           's:showhidden',
                            	\ 'switch_buffer':         's:jmptobuf',
                            	\ }, {
                            	\ 'root_markers':          's:rmarkers',
                            	\ 'user_command':          's:usrcmd',
                            	\ 'working_path_mode':     's:pathmode',
                            	\ }]
                            
                            " Global options
    1              0.000015 let s:glbs = { 'magic': 1, 'to': 1, 'tm': 0, 'sb': 1, 'hls': 0, 'im': 0,
                            	\ 'report': 9999, 'sc': 0, 'ss': 0, 'siso': 0, 'mfd': 200, 'ttimeout': 0,
                            	\ 'gcr': 'a:blinkon0', 'ic': 1, 'lmap': '', 'mousef': 0, 'imd': 1 }
                            
                            " Keymaps
    1              0.000395 let [s:lcmap, s:prtmaps] = ['nn <buffer> <silent>', {
                            	\ 'PrtBS()':              ['<bs>', '<c-]>'],
                            	\ 'PrtDelete()':          ['<del>'],
                            	\ 'PrtDeleteWord()':      ['<c-w>'],
                            	\ 'PrtClear()':           ['<c-u>'],
                            	\ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
                            	\ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
                            	\ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
                            	\ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
                            	\ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
                            	\ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
                            	\ 'PrtHistory(-1)':       ['<c-n>'],
                            	\ 'PrtHistory(1)':        ['<c-p>'],
                            	\ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
                            	\ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
                            	\ 'AcceptSelection("t")': ['<c-t>'],
                            	\ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
                            	\ 'ToggleFocus()':        ['<s-tab>'],
                            	\ 'ToggleRegex()':        ['<c-r>'],
                            	\ 'ToggleByFname()':      ['<c-d>'],
                            	\ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
                            	\ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
                            	\ 'PrtExpandDir()':       ['<tab>'],
                            	\ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
                            	\ 'PrtInsert()':          ['<c-\>'],
                            	\ 'PrtCurStart()':        ['<c-a>'],
                            	\ 'PrtCurEnd()':          ['<c-e>'],
                            	\ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
                            	\ 'PrtCurRight()':        ['<c-l>', '<right>'],
                            	\ 'PrtClearCache()':      ['<F5>'],
                            	\ 'PrtDeleteEnt()':       ['<F7>'],
                            	\ 'CreateNewFile()':      ['<c-y>'],
                            	\ 'MarkToOpen()':         ['<c-z>'],
                            	\ 'OpenMulti()':          ['<c-o>'],
                            	\ 'YankLine()':           [],
                            	\ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
                            	\ }]
                            
    1              0.000007 if !has('gui_running')
    1              0.000010 	cal add(s:prtmaps['PrtBS()'], remove(s:prtmaps['PrtCurLeft()'], 0))
    1              0.000002 en
                            
    1              0.000003 let s:ficounts = {}
                            
    1              0.000003 let s:ccex = s:pref.'clear_cache_on_exit'
                            
                            " Regexp
    1              0.000008 let s:fpats = {
                            	\ '^\(\\|\)\|\(\\|\)$': '\\|',
                            	\ '^\\\(zs\|ze\|<\|>\)': '^\\\(zs\|ze\|<\|>\)',
                            	\ '^\S\*$': '\*',
                            	\ '^\S\\?$': '\\?',
                            	\ }
                            
    1              0.000004 let s:has_conceal = has('conceal')
    1              0.000002 let s:bufnr_width = 3
                            
                            " Keypad
    1              0.000008 let s:kprange = {
                            	\ 'Plus': '+',
                            	\ 'Minus': '-',
                            	\ 'Divide': '/',
                            	\ 'Multiply': '*',
                            	\ 'Point': '.',
                            	\ }
                            
                            " Highlight groups
    1              0.000028 let s:hlgrps = {
                            	\ 'NoEntries': 'Error',
                            	\ 'Mode1': 'Character',
                            	\ 'Mode2': 'LineNr',
                            	\ 'Stats': 'Function',
                            	\ 'Match': 'Identifier',
                            	\ 'PrtBase': 'Comment',
                            	\ 'PrtText': 'Normal',
                            	\ 'PrtCursor': 'Constant',
                            	\ 'BufferNr':      'Constant',
                            	\ 'BufferInd':     'Normal',
                            	\ 'BufferHid':     'Comment',
                            	\ 'BufferHidMod':  'String',
                            	\ 'BufferVis':     'Normal',
                            	\ 'BufferVisMod':  'Identifier',
                            	\ 'BufferCur':     'Question',
                            	\ 'BufferCurMod':  'WarningMsg',
                            	\ 'BufferPath':    'Comment',
                            	\ }
                            
                            " lname, sname of the basic(non-extension) modes
    1              0.000003 let s:types = ['fil', 'buf', 'mru']
    1              0.000004 if !exists('g:ctrlp_types')
    1              0.000002 	let g:ctrlp_types = s:types
                            el
                            	call filter(g:ctrlp_types, "index(['fil', 'buf', 'mru'], v:val)!=-1")
    1              0.000001 en
    1              0.000007 let g:ctrlp_builtins = len(g:ctrlp_types)-1
                            
    1              0.000013 let s:coretype_names = {
                            	\ 'fil' : 'files',
                            	\ 'buf' : 'buffers',
                            	\ 'mru' : 'mru files',
                            	\ }
                            
    1              0.000015 let s:coretypes = map(copy(g:ctrlp_types), '[s:coretype_names[v:val], v:val]')
                            
                            " Get the options {{{2
    1              0.000003 fu! s:opts(...)
                            	unl! s:usrign s:usrcmd s:urprtmaps
                            	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
                            		let {each} = s:{each}
                            	en | endfo
                            	for [ke, va] in items(s:opts)
                            		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
                            	endfo
                            	unl va
                            	for [ke, va] in items(s:new_opts)
                            		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
                            	endfo
                            	unl va
                            	for [ke, va] in items(s:lc_opts)
                            		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
                            		en
                            	endfo
                            	" Match window options
                            	cal s:match_window_opts()
                            	" One-time values
                            	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
                            	en
                            	for each in ['byfname', 'regexp'] | if exists(each)
                            		let s:{each} = {each}
                            	en | endfo
                            	if !exists('g:ctrlp_tilde_homedir') | let g:ctrlp_tilde_homedir = 0 | en
                            	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
                            	let s:maxdepth = min([s:maxdepth, 100])
                            	let s:glob = s:showhidden ? '.*\|*' : '*'
                            	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
                            	let s:lash = ctrlp#utils#lash()
                            	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
                            	en
                            	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
                            	en
                            	" Extensions
                            	if !( exists('extensions') && extensions == s:extensions )
                            		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
                            		endfo
                            	en
                            	" Keymaps
                            	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
                            	en
                            endf
                            
    1              0.000004 fu! s:match_window_opts()
                            	let s:mw_pos =
                            		\ s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') :
                            		\ exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' )
                            		\ : 'bottom'
                            	let s:mw_order =
                            		\ s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') :
                            		\ exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' )
                            		\ : 'btt'
                            	let s:mw_max =
                            		\ s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) :
                            		\ exists('g:ctrlp_max_height') ? s:mxheight
                            		\ : 10
                            	let s:mw_min =
                            		\ s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
                            	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
                            	let s:mw_min = min([s:mw_min, s:mw_max])
                            	let s:mw_res =
                            		\ s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+'))
                            		\ : min([s:mw_max, &lines])
                            endf
                            "}}}1
                            " * Open & Close {{{1
    1              0.000002 fu! s:Open()
                            	cal s:log(1)
                            	cal s:getenv()
                            	cal s:execextvar('enter')
                            	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
                            	cal s:buffunc(1)
                            	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
                            	let [s:focus, s:prompt] = [1, ['', '', '']]
                            	abc <buffer>
                            	if !exists('s:hstry')
                            		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
                            		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
                            	en
                            	for [ke, va] in items(s:glbs) | if exists('+'.ke)
                            		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
                            	en | endfo
                            	if s:opmul != '0' && has('signs')
                            		sign define ctrlpmark text=+> texthl=CtrlPMark
                            		hi def link CtrlPMark Search
                            	en
                            	cal s:setupblank()
                            endf
                            
    1              0.000002 fu! s:Close()
                            	cal s:async_glob_abort()
                            	cal s:buffunc(0)
                            	if winnr('$') == 1
                            		bw!
                            	el
                            		try | bun!
                            		cat | clo! | endt
                            		cal s:unmarksigns()
                            	en
                            	for key in keys(s:glbs) | if exists('+'.key)
                            		sil! exe 'let &'.key.' = s:glb_'.key
                            	en | endfo
                            	if exists('s:glb_acd') | let &acd = s:glb_acd | en
                            	let g:ctrlp_lines = []
                            	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
                            		exe s:winres[0].s:winres[0]
                            	en
                            	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:init s:savestr
                            		\ s:mrbs s:did_exp
                            	cal ctrlp#recordhist()
                            	cal s:execextvar('exit')
                            	cal s:log(0)
                            	let v:errmsg = s:ermsg
                            	ec
                            endf
                            " * Clear caches {{{1
    1              0.000002 fu! ctrlp#clr(...)
                            	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]
                            endf
                            
    1              0.000002 fu! ctrlp#clra()
                            	let cadir = ctrlp#utils#cachedir()
                            	if isdirectory(cadir)
                            		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
                            		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
                            		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
                            	en
                            	cal ctrlp#clr()
                            endf
                            
    1              0.000002 fu! s:Reset(args)
                            	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
                            	cal call('s:opts', opts)
                            	cal s:autocmds()
                            	cal ctrlp#utils#opts()
                            	cal s:execextvar('opts')
                            endf
                            " * Files {{{1
    1              0.000002 fu! ctrlp#files()
                            	let cafile = ctrlp#utils#cachefile()
                            	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
                            		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
                            		if empty(lscmd)
                            			if !ctrlp#igncwd(s:dyncwd)
                            				cal s:InitCustomFuncs()
                            				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
                            				cal s:CloseCustomFuncs()
                            			en
                            		el
                            			sil! cal ctrlp#progress('Indexing...')
                            			try | cal s:UserCmd(lscmd)
                            			cat | retu [] | endt
                            		en
                            		" Remove base directory
                            		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
                            		if len(g:ctrlp_allfiles) <= s:compare_lim
                            			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
                            		en
                            		cal s:writecache(cafile)
                            		let catime = getftime(cafile)
                            	el
                            		let catime = getftime(cafile)
                            		if !( exists('s:initcwd') && s:initcwd == s:dyncwd )
                            			\ || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
                            	en
                            	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
                            	retu g:ctrlp_allfiles
                            endf
                            
    1              0.000005 fu! s:InitCustomFuncs()
                            	if s:igntype == 4 && has_key(s:usrign, 'func-init') && s:usrign['func-init'] != ''
                            		exe call(s:usrign['func-init'], [])
                            	en
                            endf
                            
    1              0.000003 fu! s:CloseCustomFuncs()
                            	if s:igntype == 4 && has_key(s:usrign, 'func-close') && s:usrign['func-close'] != ''
                            		exe call(s:usrign['func-close'], [])
                            	en
                            endf
                            
    1              0.000002 fu! s:GlobPath(dirs, depth)
                            	let entries = split(globpath(a:dirs, s:glob), "\n")
                            	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
                            	cal extend(g:ctrlp_allfiles, dnf[1])
                            	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
                            		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
                            		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
                            	en
                            endf
                            
    1              0.000003 fu! s:async_glob_update_progress(timer)
                            	let s:must_wait = 0
                            	if exists('s:focus') && get(s:, 'setlines_post_ended', 0)
                            		cal s:ForceUpdate()
                            	en
                            	if exists('s:timer')
                            		sil! cal ctrlp#statusline()
                            	endif
                            
                            	if !exists('s:job')
                            		call s:stop_timer_if_exists()
                            	endif
                            endf
                            
    1              0.000003 fu! s:async_glob_on_stdout(job, data, ...)
                            	if type(a:data) ==# type([])
                            		call extend(g:ctrlp_allfiles, filter(a:data, 'v:val !=# ""'))
                            	else
                            		call add(g:ctrlp_allfiles, a:data)
                            	endif
                            endf
                            
    1              0.000001 fu! s:async_glob_on_exit(...)
                            	let s:must_wait = 0
                            	if exists('s:job')
                            		unlet s:job
                            	endif
                            	cal s:stop_timer_if_exists()
                            	if exists('s:focus') && get(s:, 'setlines_post_ended', 0)
                            		sil! cal ctrlp#statusline()
                            		cal s:ForceUpdate()
                            	en
                            endf
                            
    1              0.000003 fu! s:async_glob_abort()
                            	cal s:stop_job_if_exists()
                            	cal s:stop_timer_if_exists()
                            	cal s:ForceUpdate()
                            endf
                            
    1              0.000004 fu! s:stop_timer_if_exists()
                            	if exists('s:timer')
                            		call timer_stop(s:timer)
                            		unlet s:timer
                            	en
                            endf
                            
    1              0.000002 fu! s:stop_job_if_exists()
                            	if exists('s:job')
                            		if !has('nvim')
                            			cal job_stop(s:job)
                            		else
                            			cal jobstop(s:job)
                            		endif
                            		unlet s:job
                            	en
                            endf
                            
    1              0.000002 fu! s:safe_printf(format, ...)
                            	try
                            		retu call('printf', [a:format] + a:000)
                            	cat
                            		retu a:format
                            	endt
                            endf
                            
    1              0.000002 fu! s:UserCmd(lscmd)
                            	let [path, lscmd] = [s:dyncwd, a:lscmd]
                            	let do_ign =
                            		\ type(s:usrcmd) == 4 && has_key(s:usrcmd, 'ignore') && s:usrcmd['ignore']
                            	if do_ign && ctrlp#igncwd(s:cwd) | retu | en
                            	if exists('+ssl') && &ssl && &shell !~ 'sh'
                            		let [ssl, &ssl, path] = [&ssl, 0, tr(path, '/', '\')]
                            	en
                            	if (has('win32') || has('win64')) && match(&shellcmdflag, "/") != -1
                            		let lscmd = substitute(lscmd, '\v(^|\&\&\s*)\zscd (/d)@!', 'cd /d ', '')
                            	en
                            	let path = exists('*shellescape') ? shellescape(path) : path
                            	if (has('win32') || has('win64')) && match(&shell, 'sh') != -1
                            		let path = tr(path, '\', '/')
                            	en
                            	if s:usrcmdasync && (v:version >= 800 || has('nvim')) && (exists('*job_start') || exists('*jobstart'))
                            		cal s:stop_job_if_exists()
                            		let g:ctrlp_allfiles = []
                            		let s:must_wait = 1
                            		let argv = [&shell, &shellcmdflag, printf(lscmd, path)]
                            		if !has('nvim')
                            			let s:job = job_start(argv, {
                            						\ 'out_cb': function('s:async_glob_on_stdout'), 
                            						\ 'exit_cb': function('s:async_glob_on_exit')
                            						\ })
                            		else
                            			let s:job = jobstart(argv, {
                            						\ 'on_stdout': function('s:async_glob_on_stdout'),
                            						\ 'on_exit': function('s:async_glob_on_exit')
                            						\ })
                            		endif
                            		let s:timer = timer_start(250, function('s:async_glob_update_progress'), {'repeat': -1})
                            		while s:must_wait
                            			sleep 50m
                            		endwhile
                            	elsei has('patch-7.4-597') && !(has('win32') || has('win64'))
                            		let g:ctrlp_allfiles = systemlist(s:safe_printf(lscmd, path))
                            	el
                            		let g:ctrlp_allfiles = split(system(s:safe_printf(lscmd, path)), "\n")
                            	en
                            	if exists('+ssl') && exists('ssl')
                            		let &ssl = ssl
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "\\", "/")')
                            	en
                            	if exists('s:vcscmd') && s:vcscmd
                            		cal map(g:ctrlp_allfiles, 'tr(v:val, "/", "\\")')
                            	en
                            	if do_ign
                            		if !empty(s:usrign)
                            			let g:ctrlp_allfiles = ctrlp#dirnfile(g:ctrlp_allfiles)[1]
                            		en
                            		if &wig != ''
                            			cal filter(g:ctrlp_allfiles, 'glob(v:val) != ""')
                            		en
                            	en
                            endf
                            
    1              0.000002 fu! s:lsCmd()
                            	let cmd = s:usrcmd
                            	if type(cmd) == 1
                            		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                            		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
                            		let s:vcscmd = s:lash == '\'
                            		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en
                            endf
                            " - Buffers {{{1
    1              0.000002 fu! s:bufparts(bufnr)
                            	let idc  = (a:bufnr == bufnr('#')      ? '#' : '')  " alternative
                            	let idc .= (getbufvar(a:bufnr, '&mod') ? '+' : '')  " modified
                            	let idc .= (getbufvar(a:bufnr, '&ma')  ? '' : '-')  " nomodifiable
                            	let idc .= (getbufvar(a:bufnr, '&ro')  ? '=' : '')  " readonly
                            
                            	" flags for highlighting
                            	let hiflags  = (bufwinnr(a:bufnr) != -1    ? '*' : '')  " visible
                            	let hiflags .= (getbufvar(a:bufnr, '&mod') ? '+' : '')  " modified
                            	let hiflags .= (a:bufnr == s:crbufnr       ? '!' : '')  " current
                            
                            	let bname = bufname(a:bufnr)
                            	let bname = (bname == '' ? '[No Name]' : fnamemodify(bname, s:bufname_mod))
                            
                            	let bpath = empty(s:bufpath_mod) ? '' : fnamemodify(bufname(a:bufnr), s:bufpath_mod).s:lash()
                            
                            	retu [idc, hiflags, bname, bpath]
                            endf
    1              0.000002 fu! ctrlp#buffers(...)
                            	let ids = sort(filter(range(1, bufnr('$')), '(empty(getbufvar(v:val, "&bt"))'
                            		\ .' || s:isterminal(v:val)) && getbufvar(v:val, "&bl")'), 's:compmreb')
                            	if a:0 && a:1 == 'id'
                            		retu ids
                            	el
                            		let bufs = [[], []]
                            		for id in ids
                            			let bname = bufname(id)
                            			let ebname = bname == ''
                            			let fname = fnamemodify(ebname ? '['.id.'*No Name]' : bname, ':.')
                            			cal add(bufs[ebname], fname)
                            		endfo
                            		retu bufs[0] + bufs[1]
                            	en
                            endf
                            " * MatchedItems() {{{1
    1              0.000003 fu! s:MatchIt(items, pat, limit, exc)
                            	let [lines, id] = [[], 0]
                            	let pat =
                            		\ s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val')
                            		\ : s:martcs.a:pat
                            	for item in a:items
                            		let id += 1
                            		try
                            			if (s:matchcrfile || !( s:ispath && item ==# a:exc )) &&
                            						\call(s:mfunc, [item, pat]) >= 0
                            				cal add(lines, item)
                            			en
                            		cat | brea | endt
                            		if a:limit > 0 && len(lines) >= a:limit | brea | en
                            	endfo
                            	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
                            	retu lines
                            endf
                            
    1              0.000003 fu! s:MatchedItems(items, pat, limit)
                            	let exc = exists('s:crfilerel') ? s:crfilerel : ''
                            	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
                            	let matcher = s:getextvar('matcher')
                            	if empty(matcher) || type(matcher) != 4 || !has_key(matcher, 'match')
                            		unlet matcher
                            		let matcher = s:matcher
                            	en
                            	if matcher != {}
                            		let argms =
                            			\ has_key(matcher, 'arg_type') && matcher['arg_type'] == 'dict' ? [{
                            			\ 'items':  items,
                            			\ 'str':    a:pat,
                            			\ 'limit':  a:limit,
                            			\ 'mmode':  s:mmode(),
                            			\ 'ispath': s:ispath,
                            			\ 'crfile': exc,
                            			\ 'regex':  s:regexp,
                            			\ }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(matcher['match'], argms, matcher)
                            	el
                            		let lines = s:MatchIt(items, a:pat, a:limit, exc)
                            	en
                            	let s:matches = len(lines)
                            	unl! s:did_exp
                            	retu lines
                            endf
                            
    1              0.000003 fu! s:SplitPattern(str)
                            	let str = a:str
                            	let s:savestr = str
                            	if s:regexp
                            		let pat = s:regexfilter(str)
                            	el
                            		let lst = split(str, '\zs')
                            		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
                            		en
                            		for each in ['^', '$', '.']
                            			cal map(lst, 'escape(v:val, each)')
                            		endfo
                            	en
                            	if exists('lst')
                            		let pat = ''
                            		if !empty(lst)
                            			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
                            			el
                            				let pat = s:buildpat(lst)
                            			en
                            		en
                            	en
                            	retu escape(pat, '~')
                            endf
                            " * BuildPrompt() {{{1
    1              0.000003 fu! s:Render(lines, pat)
                            	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
                            	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
                            	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
                            	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            
                            	" Setup the match window
                            	sil! exe '%d _ | res' height
                            	" Print the new items
                            	if empty(lines)
                            		let [s:matched, s:lines] = [[], []]
                            		let lines = [' == NO ENTRIES ==']
                            		cal setline(1, s:offset(lines, height - 1))
                            		setl noma nocul
                            		exe cur_cmd
                            		cal s:unmarksigns()
                            		if s:dohighlight() | cal clearmatches() | en
                            		retu
                            	en
                            	let s:matched = copy(lines)
                            	" Sorting
                            	if !s:nosort()
                            		let s:compat = s:martcs.pat
                            		cal sort(lines, 's:mixedsort')
                            		unl s:compat
                            	en
                            	if s:mw_order == 'btt' | cal reverse(lines) | en
                            	let s:lines = copy(lines)
                            	cal map(lines, s:flfunc)
                            	cal setline(1, s:offset(lines, height))
                            	cal s:unmarksigns()
                            	cal s:remarksigns()
                            	" Highlighting
                            	if s:dohighlight()
                            		cal s:highlight(pat, s:mathi[1])
                            	en
                            	setl noma cul
                            	exe cur_cmd
                            endf
                            
    1              0.000003 fu! s:Update(str)
                            	" Get the previous string if existed
                            	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
                            	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
                            	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
                            	" Optionally send the string to a custom validate function
                            	if s:validate != '' | let str = call(s:validate, [str]) | en
                            	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
                            	let pat = s:matcher == {} ? s:SplitPattern(str) : str
                            	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines)
                            		\ : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
                            	if empty(str) | cal clearmatches() | en
                            	cal s:Render(lines, pat)
                            	return lines
                            endf
                            
    1              0.000002 fu! s:ForceUpdate()
                            	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
                            	sil! cal s:Update(escape(s:getinput(), '\'))
                            	cal setpos('.', pos)
                            endf
                            
    1              0.000002 fu! s:BuildPrompt(upd)
                            	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
                            	let str = escape(s:getinput(), '\')
                            	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
                            	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp')
                            		\ || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
                            		sil! cal s:Update(str)
                            	en
                            	sil! cal ctrlp#statusline()
                            	" Toggling
                            	let [hiactive, hicursor, base] = s:focus
                            		\ ? ['CtrlPPrtText', 'CtrlPPrtCursor', base]
                            		\ : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
                            	let hibase = 'CtrlPPrtBase'
                            	" Build it
                            	redr
                            	let prt = copy(s:prompt)
                            	cal map(prt, 'escape(v:val, ''"\'')')
                            	exe 'echoh' hibase '| echon "'.base.'"
                            		\ | echoh' hiactive '| echon "'.prt[0].'"
                            		\ | echoh' hicursor '| echon "'.prt[1].'"
                            		\ | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
                            	if empty(prt[1]) && s:focus
                            		exe 'echoh' hibase '| echon "_" | echoh None'
                            	en
                            	if a:upd
                            		cal s:NotifySearch()
                            	en
                            endf
                            " - SetDefTxt() {{{1
    1              0.000002 fu! s:SetDefTxt()
                            	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt
                            endf
                            " ** Prt Actions {{{1
                            " Editing {{{2
    1              0.000001 fu! s:PrtClear()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [s:prompt, s:matches] = [['', '', ''], 1]
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000001 fu! s:PrtAdd(char)
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let s:prompt[0] .= a:char
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            
    1              0.000002 fu! s:PrtBS()
                            	if !s:focus | retu | en
                            	if empty(s:prompt[0]) && s:brfprt != 0
                            		cal s:PrtExit()
                            		retu
                            	en
                            	unl! s:hstgot
                            	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000002 fu! s:PrtDelete()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [prt, s:matches] = [s:prompt, 1]
                            	let prt[1] = matchstr(prt[2], '^.')
                            	let prt[2] = substitute(prt[2], '^.', '', '')
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000002 fu! s:PrtDeleteWord()
                            	if !s:focus | retu | en
                            	unl! s:hstgot
                            	let [str, s:matches] = [s:prompt[0], 1]
                            	let str = str =~ '\W\w\+$' ? matchstr(str, '^.\+\W\ze\w\+$')
                            		\ : str =~ '\w\W\+$' ? matchstr(str, '^.\+\w\ze\W\+$')
                            		\ : str =~ '\s\+$' ? matchstr(str, '^.*\S\ze\s\+$')
                            		\ : str =~ '\v^(\S+|\s+)$' ? '' : str
                            	let s:prompt[0] = str
                            	cal s:BuildPrompt(1)
                            endf
                            
    1              0.000002 fu! s:PrtInsert(...)
                            	if !s:focus | retu | en
                            	let type = !a:0 ? '' : a:1
                            	if !a:0
                            		let type = s:insertstr()
                            		if type == 'cancel' | retu | en
                            	en
                            	if type ==# 'r'
                            		let regcont = s:getregs()
                            		if regcont < 0 | retu | en
                            	en
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let s:prompt[0] .= type ==# 'w' ? s:crword
                            		\ : type ==# 'f' ? s:crgfile
                            		\ : type ==# 's' ? s:regisfilter('/')
                            		\ : type ==# 'v' ? s:crvisual
                            		\ : type ==# 'c' ? s:regisfilter('+')
                            		\ : type ==# 'r' ? regcont : ''
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            
    1              0.000001 fu! s:PrtExpandDir()
                            	if !s:focus | retu | en
                            	let str = s:getinput('c')
                            	if str =~ '\v^\@(cd|lc[hd]?|chd)\s.+' && s:spi
                            		let hasat = split(str, '\v^\@(cd|lc[hd]?|chd)\s*\zs')
                            		let str = get(hasat, 1, '')
                            		if str =~# '\v^[~$]\i{-}[\/]?|^#(\<?\d+)?:(p|h|8|\~|\.|g?s+)'
                            			let str = expand(s:fnesc(str, 'g'))
                            		elsei str =~# '\v^(\%|\<c\h{4}\>):(p|h|8|\~|\.|g?s+)'
                            			let spc = str =~# '^%' ? s:crfile
                            				\ : str =~# '^<cfile>' ? s:crgfile
                            				\ : str =~# '^<cword>' ? s:crword
                            				\ : str =~# '^<cWORD>' ? s:crnbword : ''
                            			let pat = '(:(p|h|8|\~|\.|g?s(.)[^\3]*\3[^\3]*\3))+'
                            			let mdr = matchstr(str, '\v^[^:]+\zs'.pat)
                            			let nmd = matchstr(str, '\v^[^:]+'.pat.'\zs.{-}$')
                            			let str = fnamemodify(s:fnesc(spc, 'g'), mdr).nmd
                            		en
                            	en
                            	if str == '' | retu | en
                            	unl! s:hstgot
                            	let s:act_add = 1
                            	let [base, seed] = s:headntail(str)
                            	if str =~# '^[\/]'
                            		let base = expand('/').base
                            	en
                            	let dirs = s:dircompl(base, seed)
                            	if len(dirs) == 1
                            		let str = dirs[0]
                            	elsei len(dirs) > 1
                            		let str .= s:findcommon(dirs, str)
                            	en
                            	let s:prompt[0] = exists('hasat') ? hasat[0].str : str
                            	cal s:BuildPrompt(1)
                            	unl s:act_add
                            endf
                            " Movement {{{2
    1              0.000001 fu! s:PrtCurLeft()
                            	if !s:focus | retu | en
                            	let prt = s:prompt
                            	if !empty(prt[0])
                            		let s:prompt = [substitute(prt[0], '.$', '', ''), matchstr(prt[0], '.$'),
                            			\ prt[1] . prt[2]]
                            	en
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000002 fu! s:PrtCurRight()
                            	if !s:focus | retu | en
                            	let prt = s:prompt
                            	let s:prompt = [prt[0] . prt[1], matchstr(prt[2], '^.'),
                            		\ substitute(prt[2], '^.', '', '')]
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000001 fu! s:PrtCurStart()
                            	if !s:focus | retu | en
                            	let str = join(s:prompt, '')
                            	let s:prompt = ['', matchstr(str, '^.'), substitute(str, '^.', '', '')]
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000001 fu! s:PrtCurEnd()
                            	if !s:focus | retu | en
                            	let s:prompt = [join(s:prompt, ''), '', '']
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000002 fu! s:PrtSelectMove(dir)
                            	let wht = winheight(0)
                            	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
                            	exe 'keepj norm!' dirs[a:dir]
                            	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
                            	cal s:BuildPrompt(0)
                            	cal setpos('.', pos)
                            endf
                            
    1              0.000002 fu! s:PrtSelectJump(char)
                            	let lines = copy(s:lines)
                            	if s:byfname()
                            		cal map(lines, 'split(v:val, ''[\/]\ze[^\/]\+$'')[-1]')
                            	en
                            	" Cycle through matches, use s:jmpchr to store last jump
                            	let chr = escape(matchstr(a:char, '^.'), '.~')
                            	let smartcs = &scs && chr =~ '\u' ? '\C' : ''
                            	if match(lines, smartcs.'^'.chr) >= 0
                            		" If not exists or does but not for the same char
                            		let pos = match(lines, smartcs.'^'.chr)
                            		if !exists('s:jmpchr') || ( exists('s:jmpchr') && s:jmpchr[0] != chr )
                            			let [jmpln, s:jmpchr] = [pos, [chr, pos]]
                            		elsei exists('s:jmpchr') && s:jmpchr[0] == chr
                            			" Start of lines
                            			if s:jmpchr[1] == -1 | let s:jmpchr[1] = pos | en
                            			let npos = match(lines, smartcs.'^'.chr, s:jmpchr[1] + 1)
                            			let [jmpln, s:jmpchr] = [npos == -1 ? pos : npos, [chr, npos]]
                            		en
                            		exe 'keepj norm!' ( jmpln + 1 ).'G'
                            		let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
                            		cal s:BuildPrompt(0)
                            		cal setpos('.', pos)
                            	en
                            endf
                            " Misc {{{2
    1              0.000002 fu! s:PrtFocusMap(char)
                            	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])
                            endf
                            
    1              0.000001 fu! s:PrtClearCache()
                            	let ct = s:curtype()
                            	if ct == 'fil'
                            		cal ctrlp#clr()
                            	elsei s:itemtype >= len(s:coretypes)
                            		cal ctrlp#clr(s:statypes[s:itemtype][1])
                            	en
                            	if ct == 'mru'
                            		let g:ctrlp_lines = ctrlp#mrufiles#refresh()
                            	el
                            		cal ctrlp#setlines()
                            	en
                            	let s:force = 1
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            
    1              0.000001 fu! s:PrtDeleteEnt()
                            	let ct = s:curtype()
                            	if ct == 'mru'
                            		cal s:PrtDeleteMRU()
                            	elsei ct == 'buf'
                            		cal s:delbuf()
                            	elsei type(s:getextvar('wipe')) == 1
                            		cal s:delent(s:getextvar('wipe'))
                            	en
                            endf
                            
    1              0.000002 fu! s:PrtDeleteMRU()
                            	if s:curtype() == 'mru'
                            		cal s:delent('ctrlp#mrufiles#remove')
                            	en
                            endf
                            
    1              0.000002 fu! s:PrtExit()
                            	let bw = bufwinnr('%')
                            	exe bufwinnr(s:bufnr).'winc w'
                            	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
                            		noa cal s:Close()
                            		noa winc p
                            	els
                            		exe bw.'winc w'
                            	en
                            endf
                            
    1              0.000002 fu! s:PrtHistory(...)
                            	if !s:focus || !s:maxhst | retu | en
                            	let [str, hst, s:matches] = [join(s:prompt, ''), s:hstry, 1]
                            	" Save to history if not saved before
                            	let [hst[0], hslen] = [exists('s:hstgot') ? hst[0] : str, len(hst)]
                            	let idx = exists('s:hisidx') ? s:hisidx + a:1 : a:1
                            	" Limit idx within 0 and hslen
                            	let idx = idx < 0 ? 0 : idx >= hslen ? hslen > 1 ? hslen - 1 : 0 : idx
                            	let s:prompt = [hst[idx], '', '']
                            	let [s:hisidx, s:hstgot, s:force] = [idx, 1, 1]
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            "}}}1
                            " * Mappings {{{1
    1              0.000001 fu! s:MapNorms()
                            	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
                            	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
                            	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
                            	let pfunc = 'PrtFocusMap'
                            	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
                            	for each in [34, 92, 124]
                            		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
                            	endfo
                            	for each in ranges
                            		exe printf(cmd, each, pfunc, nr2char(each))
                            	endfo
                            	for each in range(0, 9)
                            		exe printf(pcmd, each, pfunc, each)
                            	endfo
                            	for [ke, va] in items(s:kprange)
                            		exe printf(pcmd, ke, pfunc, va)
                            	endfo
                            	let s:nmapped = s:bufnr
                            endf
                            
    1              0.000003 fu! s:MapSpecs()
                            	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
                            		if ( has('termresponse') && v:termresponse =~ "\<ESC>" )
                            			\ || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi|tmux|st(-[-a-z0-9]*)?(\:tc)?$'
                            			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
                            				exe s:lcmap.' <esc>['.each
                            			endfo
                            		en
                            	en
                            	for [ke, va] in items(s:prtmaps) | for kp in va
                            		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
                            	endfo | endfo
                            	let s:smapped = s:bufnr
                            endf
                            
    1              0.000006 fu! s:KeyLoop()
                            	let [t_ve, guicursor] = [&t_ve, &guicursor]
                            	wh exists('s:init') && s:keyloop
                            		try
                            			set t_ve=
                            			if guicursor != ''
                            				set guicursor=a:NONE
                            			en
                            			let nr = getchar()
                            		fina
                            			let &t_ve = t_ve
                            			let &guicursor = guicursor
                            		endt
                            		let chr = !type(nr) ? nr2char(nr) : nr
                            		if nr >=# 0x20
                            			cal s:PrtFocusMap(chr)
                            		el
                            			let cmd = matchstr(maparg(chr), ':<C-U>\zs.\+\ze<CR>$')
                            			try
                            				exe ( cmd != '' ? cmd : 'norm '.chr )
                            			cat
                            			endt
                            		en
                            	endw
                            endf
                            " * Toggling {{{1
    1              0.000002 fu! s:ToggleFocus()
                            	let s:focus = !s:focus
                            	cal s:BuildPrompt(0)
                            endf
                            
    1              0.000001 fu! s:ToggleRegex()
                            	let s:regexp = !s:regexp
                            	cal s:PrtSwitcher()
                            endf
                            
    1              0.000001 fu! s:ToggleByFname()
                            	if s:ispath
                            		let s:byfname = !s:byfname
                            		let s:mfunc = s:mfunc()
                            		cal s:PrtSwitcher()
                            	en
                            endf
                            
    1              0.000001 fu! s:ToggleType(dir)
                            	cal s:async_glob_abort()
                            	let max = len(g:ctrlp_ext_vars) + len(s:coretypes) - 1
                            	let next = s:walker(max, s:itemtype, a:dir)
                            	cal ctrlp#setlines(next)
                            	cal ctrlp#syntax()
                            	cal s:PrtSwitcher()
                            endf
                            
    1              0.000001 fu! s:ToggleKeyLoop()
                            	let s:keyloop = !s:keyloop
                            	if exists('+imd')
                            		let &imd = !s:keyloop
                            	en
                            	if s:keyloop
                            		let [&ut, s:lazy] = [0, 0]
                            		cal s:KeyLoop()
                            	elsei has_key(s:glbs, 'ut')
                            		let [&ut, s:lazy] = [s:glbs['ut'], 1]
                            	en
                            endf
                            
    1              0.000001 fu! s:ToggleMRURelative()
                            	cal ctrlp#mrufiles#tgrel()
                            	cal s:PrtClearCache()
                            endf
                            
    1              0.000001 fu! s:PrtSwitcher()
                            	let [s:force, s:matches] = [1, 1]
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            " - SetWD() {{{1
    1              0.000002 fu! s:SetWD(args)
                            	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0
                            		\ && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
                            	en
                            	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
                            	en
                            	let pmodes = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
                            	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
                            	if (!type(pmodes))
                            		let pmodes =
                            			\ pmodes == 0 ? '' :
                            			\ pmodes == 1 ? 'a' :
                            			\ pmodes == 2 ? 'r' :
                            			\ 'c'
                            	en
                            	let spath = pmodes =~ 'd' ? s:dyncwd : pmodes =~ 'w' ? s:cwd : s:crfpath
                            	for pmode in split(pmodes, '\zs')
                            		if ctrlp#setpathmode(pmode, spath) | retu | en
                            	endfo
                            endf
                            " * AcceptSelection() {{{1
    1              0.000002 fu! ctrlp#acceptfile(...)
                            	let useb = 0
                            	if a:0 == 1 && type(a:1) == 4
                            		let [md, line] = [a:1['action'], a:1['line']]
                            		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
                            	el
                            		let [md, line] = [a:1, a:2]
                            		let atl = a:0 > 2 ? a:3 : ''
                            	en
                            	if !type(line)
                            		let [filpath, bufnr, useb] = [line, line, 1]
                            	el
                            		let [bufnr, filpath] = s:bufnrfilpath(line)
                            		if bufnr == filpath
                            			let useb = 1
                            		en
                            	en
                            	cal s:PrtExit()
                            	let tail = s:tail()
                            	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
                            	let openmyself = bufnr == bufnr('%')
                            	if bufnr > 0 && ( !empty(s:jmptobuf) && s:jmptobuf =~ md )
                            		\ && !( md == 'e' && openmyself )
                            		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
                            		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 )
                            			\ ? s:buftab(bufnr, md) : [0, 0]
                            	en
                            	" Switch to existing buffer or open new one
                            	if exists('jmpb') && bufwinnr > 0
                            		\ && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
                            		exe bufwinnr.'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	elsei exists('jmpb') && buftab[0]
                            		\ && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
                            		exe 'tabn' buftab[0]
                            		exe buftab[1].'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
                            	el
                            		" Determine the command to use
                            		let useb = bufnr > 0 && ( buflisted(bufnr) || openmyself ) && ( empty(tail) || useb )
                            		let cmd =
                            			\ md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) :
                            			\ md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) :
                            			\ md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) :
                            			\ &bt == 'help' && openmyself ? 'b' :
                            			\ call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
                            		" Reset &switchbuf option
                            		let [swb, &swb] = [&swb, '']
                            		" Open new window/buffer
                            		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
                            		let args = [cmd, fid, tail, 1, [useb, j2l]]
                            		cal call('s:openfile', args)
                            		let &swb = swb
                            	en
                            endf
                            
    1              0.000002 fu! s:SpecInputs(str)
                            	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
                            		let cwd = s:dyncwd
                            		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ?
                            			\ '../'.repeat('../', strlen(a:str) - 2) : a:str)
                            		if cwd != s:dyncwd | cal ctrlp#setlines() | en
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str == s:lash && s:spi
                            		cal s:SetWD({ 'mode': 'rd' })
                            		cal ctrlp#setlines()
                            		cal s:PrtClear()
                            		retu 1
                            	elsei a:str =~ '^@.\+' && s:spi
                            		retu s:at(a:str)
                            	elsei a:str == '?'
                            		cal s:PrtExit()
                            		let hlpwin = &columns > 159 ? '| vert res 80' : ''
                            		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000003 fu! s:AcceptSelection(action)
                            	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
                            	let subm = icr || ( !icr && md == 'e' )
                            	if !subm && s:OpenMulti(md) != -1 | retu | en
                            	let str = s:getinput()
                            	if subm | if s:SpecInputs(str) | retu | en | en
                            	" Get the selected line
                            	let line = ctrlp#getcline()
                            	if !subm && s:curtype() != 'fil' && line == '' && line('.') > s:offset
                            		\ && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
                            		cal s:CreateNewFile(md) | retu
                            	en
                            	if empty(line) | retu | en
                            	" Do something with it
                            	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            		let actfunc = s:openfunc[s:ctype]
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
                            	el
                            		if s:itemtype < len(s:coretypes)
                            			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
                            		el
                            			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
                            			let type = exttype == 'dict' ? exttype : 'list'
                            		en
                            	en
                            	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr, 'input': str}]
                            		\ : [md, line]
                            	cal call(actfunc, actargs)
                            endf
                            " - CreateNewFile() {{{1
    1              0.000002 fu! s:CreateNewFile(...)
                            	let [md, str] = ['', s:getinput('n')]
                            	if empty(str) | retu | en
                            	if s:argmap && !a:0
                            		" Get the extra argument
                            		let md = s:argmaps(md, 1)
                            		if md == 'cancel' | retu | en
                            	en
                            	let str = s:sanstail(str)
                            	let [base, fname] = s:headntail(str)
                            	if fname =~ '^[\/]$' | retu | en
                            	if exists('s:marked') && len(s:marked)
                            		" Use the first marked file's path
                            		let path = fnamemodify(values(s:marked)[0], ':p:h')
                            		let base = path.s:lash(path).base
                            		let str = fnamemodify(base.s:lash.fname, ':.')
                            	en
                            	if base != '' | if isdirectory(ctrlp#utils#mkdir(base))
                            		let optyp = str | en | el | let optyp = fname
                            	en
                            	if !exists('optyp') | retu | en
                            	let [filpath, tail] = [fnamemodify(optyp, ':p'), s:tail()]
                            	if !stridx(filpath, s:dyncwd) | cal s:insertcache(str) | en
                            	cal s:PrtExit()
                            	let cmd = md == 'r' ? ctrlp#normcmd('e') :
                            		\ s:newfop =~ '1\|t' || ( a:0 && a:1 == 't' ) || md == 't' ? 'tabe' :
                            		\ s:newfop =~ '2\|h' || ( a:0 && a:1 == 'h' ) || md == 'h' ? 'new' :
                            		\ s:newfop =~ '3\|v' || ( a:0 && a:1 == 'v' ) || md == 'v' ? 'vne' :
                            		\ ctrlp#normcmd('e')
                            	cal s:openfile(cmd, filpath, tail, 1)
                            endf
                            " * OpenMulti() {{{1
    1              0.000002 fu! s:MarkToOpen()
                            	let ct = s:curtype()
                            	if s:bufnr <= 0 || s:opmul == '0'
                            		\ || ( s:itemtype >= len(s:coretypes) && s:getextvar('opmul') != 1 )
                            		retu
                            	en
                            	let line = ctrlp#getcline()
                            
                            	" Do not allow to mark modified or current buffer
                            	let bufnr = s:bufnrfilpath(line)[0]
                            	if (ct == 'buf' && s:delbufcond(bufnr))
                            		retu
                            	en
                            
                            	if empty(line) | retu | en
                            	let filpath = s:ispath ? fnamemodify(line, ':p') : line
                            	if exists('s:marked') && s:dictindex(s:marked, filpath) > 0
                            		" Unmark and remove the file from s:marked
                            		let key = s:dictindex(s:marked, filpath)
                            		cal remove(s:marked, key)
                            		if empty(s:marked) | unl s:marked | en
                            		if has('signs')
                            			exe 'sign unplace' key 'buffer='.s:bufnr
                            		en
                            	el
                            		" Add to s:marked and place a new sign
                            		if exists('s:marked')
                            			let vac = s:vacantdict(s:marked)
                            			let key = empty(vac) ? len(s:marked) + 1 : vac[0]
                            			let s:marked = extend(s:marked, { key : filpath })
                            		el
                            			let [key, s:marked] = [1, { 1 : filpath }]
                            		en
                            		if has('signs')
                            			exe 'sign place' key 'line='.line('.').' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	en
                            	sil! cal ctrlp#statusline()
                            endf
                            
    1              0.000002 fu! s:OpenMulti(...)
                            	let has_marked = exists('s:marked')
                            	if ( !has_marked && a:0 ) || s:opmul == '0' || !s:ispath
                            		\ || ( s:itemtype >= len(s:coretypes) && s:getextvar('opmul') != 1 )
                            		retu -1
                            	en
                            	" Get the options
                            	let [nr, md] = [matchstr(s:opmul, '\d\+'), matchstr(s:opmul, '[thvi]')]
                            	let [ur, jf] = [s:opmul =~ 'r', s:opmul =~ 'j']
                            	let md = a:0 ? a:1 : ( md == '' ? 'v' : md )
                            	let nopt = exists('g:ctrlp_open_multiple_files')
                            	if !has_marked
                            		let line = ctrlp#getcline()
                            		if line == '' | retu | en
                            		let marked = { 1 : fnamemodify(line, ':p') }
                            		let [nr, ur, jf, nopt] = ['1', 0, 0, 1]
                            	en
                            	if ( s:argmap || !has_marked ) && !a:0
                            		let md = s:argmaps(md, !has_marked ? 2 : 0)
                            		if md == 'c'
                            			cal s:unmarksigns()
                            			unl! s:marked
                            			cal s:BuildPrompt(0)
                            		elsei !has_marked && md =~ '[axd]'
                            			retu s:OpenNoMarks(md, line)
                            		en
                            		if md =~ '\v^c(ancel)?$' | retu | en
                            		let nr = nr == '0' ? ( nopt ? '' : '1' ) : nr
                            		let ur = !has_marked && md == 'r' ? 1 : ur
                            	en
                            	let mkd = values(has_marked ? s:marked : marked)
                            	cal s:sanstail(join(s:prompt, ''))
                            	cal s:PrtExit()
                            	if nr == '0' || md == 'i'
                            		retu map(mkd, "s:openfile('bad', v:val, '', 0)")
                            	en
                            	let tail = s:tail()
                            	let [emptytail, bufnr] = [empty(tail), bufnr('^'.mkd[0].'$')]
                            	let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            	" Move to a replaceable window
                            	let ncmd = ( useb ? ['b', 'bo vert sb'] : ['e', 'bo vne'] )
                            		\ + ( ur ? [] : ['ignruw'] )
                            	let fst = call('ctrlp#normcmd', ncmd)
                            	" Check if the current window has a replaceable buffer
                            	let repabl = !( md == 't' && !ur ) && empty(bufname('%')) && empty(&l:ft)
                            	" Commands for the rest of the files
                            	let [ic, cmds] = [1, { 'v': ['vert sb', 'vne'], 'h': ['sb', 'new'],
                            		\ 't': ['tab sb', 'tabe'] }]
                            	let [swb, &swb] = [&swb, '']
                            	if md == 't' && ctrlp#tabcount() < tabpagenr()
                            		let s:tabct = ctrlp#tabcount()
                            	en
                            	" Open the files
                            	for va in mkd
                            		let bufnr = bufnr('^'.va.'$')
                            		if bufnr < 0 && getftype(va) == '' | con | en
                            		let useb = bufnr > 0 && buflisted(bufnr) && emptytail
                            		let snd = md != '' && has_key(cmds, md) ?
                            			\ ( useb ? cmds[md][0] : cmds[md][1] ) : ( useb ? 'vert sb' : 'vne' )
                            		let cmd = ic == 1 && ( !( !ur && fst =~ '^[eb]$' ) || repabl ) ? fst : snd
                            		let conds = [( nr != '' && nr > 1 && nr < ic ) || ( nr == '' && ic > 1 ),
                            			\ nr != '' && nr < ic]
                            		if conds[nopt]
                            			if !buflisted(bufnr) | cal s:openfile('bad', va, '', 0) | en
                            		el
                            			cal s:openfile(cmd, useb ? bufnr : va, tail, ic == 1)
                            			if jf | if ic == 1
                            				let crpos = [tabpagenr(), winnr()]
                            			el
                            				let crpos[0] += tabpagenr() <= crpos[0]
                            				let crpos[1] += winnr() <= crpos[1]
                            			en | en
                            			let ic += 1
                            		en
                            	endfo
                            	if jf && exists('crpos') && ic > 2
                            		exe ( md == 't' ? 'tabn '.crpos[0] : crpos[1].'winc w' )
                            	en
                            	let &swb = swb
                            	unl! s:tabct
                            endf
                            
    1              0.000001 fu! s:YankLine(...)
                            	let @" = s:getinput()
                            	let has_marked = exists('s:marked')
                            	if !has_marked
                            		let line = ctrlp#getcline()
                            		if line == '' | retu | en
                            		let marked = { 1 : fnamemodify(line, ':p') }
                            	en
                            	let @" = join(values(has_marked ? s:marked : marked), "\n")
                            	cal s:PrtExit()
                            endf
                            
    1              0.000001 fu! s:OpenNoMarks(md, line)
                            	if a:md == 'a'
                            		let [s:marked, key] = [{}, 1]
                            		for line in s:lines
                            			let s:marked = extend(s:marked, { key : fnamemodify(line, ':p') })
                            			let key += 1
                            		endfo
                            		cal s:remarksigns()
                            		cal s:BuildPrompt(0)
                            	elsei a:md == 'x'
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'dict'
                            		let argms = type == 'dict' ? [{ 'action': a:md, 'line': a:line }]
                            			\ : [a:md, a:line]
                            		cal call(s:openfunc[s:ctype], argms, s:openfunc)
                            	elsei a:md == 'd'
                            		let dir = fnamemodify(a:line, ':h')
                            		if isdirectory(dir)
                            			cal ctrlp#setdir(dir)
                            			cal ctrlp#switchtype(0)
                            			cal ctrlp#recordhist()
                            			cal s:PrtClear()
                            		en
                            	en
                            endf
                            " ** Helper functions {{{1
                            " Sorting {{{2
    1              0.000002 fu! ctrlp#complen(...)
                            	" By length
                            	let [len1, len2] = [strlen(a:1), strlen(a:2)]
                            	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
                            endf
                            
    1              0.000001 fu! s:compmatlen(...)
                            	" By match length
                            	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
                            	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
                            	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1
                            endf
                            
    1              0.000002 fu! s:comptime(...)
                            	" By last modified time
                            	let [time1, time2] = [getftime(a:1), getftime(a:2)]
                            	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1
                            endf
                            
    1              0.000001 fu! s:compmreb(...)
                            	" By last entered time (bufnr)
                            	let [id1, id2] = [index(s:mrbs, a:1), index(s:mrbs, a:2)]
                            	if id1 == id2
                            		return 0
                            	endif
                            	if id1 < 0
                            		return 1
                            	endif
                            	if id2 < 0
                            		return -1
                            	endif
                            	return id1 > id2 ? 1 : -1
                            endf
                            
    1              0.000001 fu! s:compmref(...)
                            	" By last entered time (MRU)
                            	let [id1, id2] = [index(g:ctrlp_lines, a:1), index(g:ctrlp_lines, a:2)]
                            	retu id1 == id2 ? 0 : id1 > id2 ? 1 : -1
                            endf
                            
    1              0.000001 fu! s:comparent(...)
                            	" By same parent dir
                            	if !stridx(s:crfpath, s:dyncwd)
                            		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
                            		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
                            		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
                            		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
                            		retu 0
                            	en
                            	retu 0
                            endf
                            
    1              0.000001 fu! s:compfnlen(...)
                            	" By filename length
                            	let len1 = strlen(split(a:1, s:lash)[-1])
                            	let len2 = strlen(split(a:2, s:lash)[-1])
                            	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1
                            endf
                            
    1              0.000002 fu! s:matchlens(str, pat, ...)
                            	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
                            	let st   = a:0 ? a:1 : 0
                            	let lens = a:0 >= 2 ? a:2 : {}
                            	let nr   = a:0 >= 3 ? a:3 : 0
                            	if nr > 20 | retu {} | en
                            	if match(a:str, a:pat, st) >= 0
                            		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
                            		let lens = extend(lens, { nr : [strlen(mst), mst] })
                            		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
                            	en
                            	retu lens
                            endf
                            
    1              0.000002 fu! s:shortest(lens)
                            	retu min(map(values(a:lens), 'v:val[0]'))
                            endf
                            
    1              0.000001 fu! s:mixedsort(...)
                            	let ct = s:curtype()
                            	if ct == 'buf'
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
                            	en
                            	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
                            	if s:ispath
                            		let ms = []
                            		if s:res_count < 21
                            			let ms += [s:compfnlen(a:1, a:2)]
                            			if ct !~ '^\(buf\|mru\)$' | let ms += [s:comptime(a:1, a:2)] | en
                            			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
                            		en
                            		if ct =~ '^\(buf\|mru\)$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
                            		en
                            		let ms += [cml, 0, 0, 0]
                            		let mp = call('s:multipliers', ms[:3])
                            		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2
                            endf
                            
    1              0.000002 fu! s:multipliers(...)
                            	let mp0 = !a:1 ? 0 : 2
                            	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
                            	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
                            	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
                            	retu [mp0, mp1, mp2, mp3]
                            endf
                            
    1              0.000002 fu! s:compval(...)
                            	retu a:1 - a:2
                            endf
                            " Statusline {{{2
    1              0.000001 fu! ctrlp#statusline()
                            	if !exists('s:statypes')
                            		let s:statypes = copy(s:coretypes)
                            		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars),
                            				\ 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
                            		en
                            	en
                            	let tps = s:statypes
                            	let max = len(tps) - 1
                            	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
                            	let prv = tps[s:walker(max, s:itemtype, -1)][1]
                            	let s:ctype = tps[s:itemtype][0]
                            	let focus   = s:focus ? 'prt'  : 'win'
                            	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
                            	let marked  = s:opmul != '0' ?
                            		\ exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
                            	if s:status != {}
                            		let argms =
                            			\ has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{
                            			\ 'focus':   focus,
                            			\ 'byfname': byfname,
                            			\ 'regex':   s:regexp,
                            			\ 'prev':    prv,
                            			\ 'item':    s:ctype,
                            			\ 'next':    nxt,
                            			\ 'marked':  marked,
                            			\ }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
                            		let &l:stl = call(s:status['main'], argms, s:status)
                            	el
                            		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
                            		let focus   = '%#CtrlPMode2# '.focus.' %*'
                            		let byfname = '%#CtrlPMode1# '.byfname.' %*'
                            		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
                            		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
                            		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
                            		let &l:stl  = focus.byfname.regex.slider.marked.dir
                            		if exists('s:timer')
                            			let &l:stl = '%#CtrlPStats# '.len(g:ctrlp_allfiles).' '.&l:stl
                            		en
                            	en
                            endf
                            
    1              0.000002 fu! s:dismrk()
                            	retu has('signs') ? len(s:marked) :
                            		\ '%<'.join(values(map(copy(s:marked), 'split(v:val, "[\\/]")[-1]')), ', ')
                            endf
                            
    1              0.000002 fu! ctrlp#progress(enum, ...)
                            	if has('macunix') || has('mac') | sl 1m | en
                            	let txt = a:0 ? '(press ctrl-c to abort)' : ''
                            	if s:status != {}
                            		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict'
                            			\ ? [{ 'str': a:enum }] : [a:enum]
                            		let &l:stl = call(s:status['prog'], argms, s:status)
                            	el
                            		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
                            	en
                            	redraws
                            endf
                            " *** Paths {{{2
                            " Line formatting {{{3
    1              0.000001 fu! s:formatline(str)
                            	let str = a:str
                            	let ct = s:curtype()
                            	if ct == 'buf'
                            		let bufnr = s:bufnrfilpath(str)[0]
                            		let parts = s:bufparts(bufnr)
                            		let str = printf('%'.s:bufnr_width.'s', bufnr)
                            		if s:has_conceal && has('syntax_items')
                            			let str .= printf(' %-13s %s%-36s',
                            				\ '<bi>'.parts[0].'</bi>',
                            				\ '<bn>'.parts[1], '{'.parts[2].'}</bn>')
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', '<bp>'.parts[3].'</bp>')
                            			en
                            		el
                            			let str .= printf(' %-5s %-30s',
                            				\ parts[0],
                            				\ parts[2])
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', parts[3])
                            			en
                            		en
                            	en
                            	let cond = ct != 'buf' &&s:ispath && ( s:winw - 4 ) < s:strwidth(str)
                            	retu s:lineprefix.( cond ? s:pathshorten(str) : str )
                            endf
                            
    1              0.000002 fu! s:pathshorten(str)
                            	retu matchstr(a:str, '^.\{9}').'...'
                            		\ .matchstr(a:str, '.\{'.( s:winw - 16 ).'}$')
                            endf
                            
    1              0.000002 fu! s:offset(lines, height)
                            	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
                            	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines
                            endf
                            " Directory completion {{{3
    1              0.000002 fu! s:dircompl(be, sd)
                            	if a:sd == '' | retu [] | en
                            	if a:be == ''
                            		let [be, sd] = [s:dyncwd, a:sd]
                            	el
                            		let be = a:be.s:lash(a:be)
                            		let sd = be.a:sd
                            	en
                            	let dirs = split(globpath(s:fnesc(be, 'g', ','), a:sd.'*/'), "\n")
                            	if a:be == ''
                            		let dirs = ctrlp#rmbasedir(dirs)
                            	en
                            	cal filter(dirs, '!match(v:val, escape(sd, ''~$.\''))'
                            		\ . ' && v:val !~ ''\v(^|[\/])\.{1,2}[\/]$''')
                            	retu dirs
                            endf
                            
    1              0.000001 fu! s:findcommon(items, seed)
                            	let [items, id, cmn, ic] = [copy(a:items), strlen(a:seed), '', 0]
                            	cal map(items, 'strpart(v:val, id)')
                            	for char in split(items[0], '\zs')
                            		for item in items[1:]
                            			if item[ic] != char | let brk = 1 | brea | en
                            		endfo
                            		if exists('brk') | brea | en
                            		let cmn .= char
                            		let ic += 1
                            	endfo
                            	retu cmn
                            endf
                            " Misc {{{3
    1              0.000002 fu! s:headntail(str)
                            	let parts = split(a:str, '[\/]\ze[^\/]\+[\/:]\?$')
                            	retu len(parts) == 1 ? ['', parts[0]] : len(parts) == 2 ? parts : []
                            endf
                            
    1              0.000002 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000002 fu! s:ispathitem()
                            	retu s:itemtype < len(s:coretypes) || s:getextvar('type') == 'path'
                            endf
                            
    1              0.000001 fu! ctrlp#igncwd(cwd)
                            	retu ctrlp#utils#glob(a:cwd, 0) == '' ||
                            		\ ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )
                            endf
                            
    1              0.000001 fu! ctrlp#dirnfile(entries)
                            	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
                            	for each in a:entries
                            		let etype = getftype(each)
                            		if s:igntype >= 0 && s:usrign(each, etype) | con | en
                            		if etype == 'dir'
                            			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                            				cal add(items[0], each)
                            			en | el
                            				cal add(items[0], each)
                            			en
                            		elsei etype == 'link'
                            			if s:folsym
                            				let isfile = !isdirectory(each)
                            				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                            					cal add(items[isfile], each)
                            				en
                            			en
                            		elsei etype == 'file'
                            			cal add(items[1], each)
                            		en
                            	endfo
                            	retu items
                            endf
                            
    1              0.000002 fu! s:usrign(item, type)
                            	if s:igntype == 1 | retu a:item =~ s:usrign | en
                            	if s:igntype == 2
                            		if call(s:usrign, [a:item, a:type])
                            			retu 1
                            		en
                            	elsei s:igntype == 4
                            		if has_key(s:usrign, a:type) && s:usrign[a:type] != ''
                            					\ && a:item =~ s:usrign[a:type]
                            			retu 1
                            		elsei has_key(s:usrign, 'func') && s:usrign['func'] != ''
                            					\ && call(s:usrign['func'], [a:item, a:type])
                            			retu 1
                            		en
                            	en
                            	retu 0
                            endf
                            
    1              0.000002 fu! s:samerootsyml(each, isfile, cwd)
                            	let resolve = fnamemodify(resolve(a:each), ':p:h')
                            	let resolve .= s:lash(resolve)
                            	retu !( stridx(resolve, a:cwd) && ( stridx(a:cwd, resolve) || a:isfile ) )
                            endf
                            
    1              0.000001 fu! ctrlp#rmbasedir(items)
                            	if a:items == []
                            		retu a:items
                            	en
                            	let cwd = s:dyncwd.s:lash()
                            	let first = a:items[0]
                            	if has('win32') || has('win64')
                            		let cwd = tr(cwd, '\', '/')
                            		let first = tr(first, '\', '/')
                            	en
                            	if !stridx(first, cwd)
                            		let idx = strlen(cwd)
                            		retu map(a:items, 'strpart(v:val, idx)')
                            	en
                            	retu a:items
                            endf
                            " Working directory {{{3
    1              0.000001 fu! s:getparent(item)
                            	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
                            	if parent == '' || parent !~ '[\/]'
                            		let parent .= s:lash
                            	en
                            	retu parent
                            endf
                            
    1              0.000003 fu! s:findroot(curr, mark, depth, type)
                            	let [depth, fnd] = [a:depth + 1, 0]
                            	if type(a:mark) == 1
                            		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
                            	elsei type(a:mark) == 3
                            		for markr in a:mark
                            			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
                            				let fnd = 1
                            				brea
                            			en
                            		endfo
                            	en
                            	if fnd
                            		if !a:type | cal ctrlp#setdir(a:curr) | en
                            		retu [exists('markr') ? markr : a:mark, a:curr]
                            	elsei depth > s:maxdepth
                            		cal ctrlp#setdir(s:cwd)
                            	el
                            		let parent = s:getparent(a:curr)
                            		if parent != a:curr
                            			retu s:findroot(parent, a:mark, depth, a:type)
                            		en
                            	en
                            	retu []
                            endf
                            
    1              0.000002 fu! ctrlp#setpathmode(pmode, ...)
                            	if a:pmode == 'c' || ( a:pmode == 'a' && stridx(s:crfpath, s:cwd) < 0 )
                            		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                            		cal ctrlp#setdir(s:crfpath)
                            		retu 1
                            	elsei a:pmode == 'r'
                            		let spath = a:0 ? a:1 : s:crfpath
                            		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
                            		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu 1 | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            			let markers = s:rmarkers + markers
                            		en
                            		if s:findroot(spath, markers, 0, 0) != [] | retu 1 | en
                            	en
                            	retu 0
                            endf
                            
    1              0.000002 fu! ctrlp#setdir(path, ...)
                            	let cmd = a:0 ? a:1 : 'lc!'
                            	sil! exe cmd s:fnesc(a:path, 'c')
                            	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
                            endf
                            " Fallbacks {{{3
    1              0.000001 fu! s:glbpath(...)
                            	retu call('ctrlp#utils#globpath', a:000)
                            endf
                            
    1              0.000001 fu! s:fnesc(...)
                            	retu call('ctrlp#utils#fnesc', a:000)
                            endf
                            
    1              0.000001 fu! ctrlp#setlcdir()
                            	if exists('*haslocaldir')
                            		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
                            	en
                            endf
                            " Highlighting {{{2
    1              0.000001 fu! ctrlp#syntax()
                            	if ctrlp#nosy() | retu | en
                            	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
                            	let bgColor=synIDattr(synIDtrans(hlID('Normal')), 'bg')
                            	if bgColor !~ '^-1$\|^$'
                            		sil! exe 'hi CtrlPLinePre guifg='.bgColor.' ctermfg='.bgColor
                            	en
                            	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
                            	if hlexists('CtrlPLinePre')
                            		exe "sy match CtrlPLinePre '^".escape(get(g:, 'ctrlp_line_prefix', '>'),'^$.*~\')."'"
                            	en
                            
                            	if s:curtype() == 'buf' && s:has_conceal
                            		sy region CtrlPBufferNr     matchgroup=CtrlPLinePre start='^>\s\+' end='\s'
                            		sy region CtrlPBufferInd    concealends matchgroup=Ignore start='<bi>' end='</bi>'
                            		sy region CtrlPBufferRegion concealends matchgroup=Ignore start='<bn>' end='</bn>'
                            			\ contains=CtrlPBufferHid,CtrlPBufferHidMod,CtrlPBufferVis,CtrlPBufferVisMod,CtrlPBufferCur,CtrlPBufferCurMod
                            		sy region CtrlPBufferHid    concealends matchgroup=Ignore     start='\s*{' end='}' contained
                            		sy region CtrlPBufferHidMod concealends matchgroup=Ignore    start='+\s*{' end='}' contained
                            		sy region CtrlPBufferVis    concealends matchgroup=Ignore   start='\*\s*{' end='}' contained
                            		sy region CtrlPBufferVisMod concealends matchgroup=Ignore  start='\*+\s*{' end='}' contained
                            		sy region CtrlPBufferCur    concealends matchgroup=Ignore  start='\*!\s*{' end='}' contained
                            		sy region CtrlPBufferCurMod concealends matchgroup=Ignore start='\*+!\s*{' end='}' contained
                            		sy region CtrlPBufferPath   concealends matchgroup=Ignore start='<bp>' end='</bp>'
                            	en
                            endf
                            
    1              0.000002 fu! s:highlight(pat, grp)
                            	if s:matcher != {} | retu | en
                            	cal clearmatches()
                            	if !empty(a:pat) && s:ispath
                            		if s:regexp
                            			let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            			cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
                            		el
                            			let pat = a:pat
                            
                            			" get original characters so we can rebuild pat
                            			let chars = split(pat, '\[\^\\\?.\]\\{-}')
                            
                            			" Build a pattern like /a.*b.*c/ from abc (but with .\{-} non-greedy
                            			" matchers instead)
                            			let pat = join(chars, '.\{-}')
                            			" Ensure we match the last version of our pattern
                            			let ending = '\(.*'.pat.'\)\@!'
                            			" Case sensitive?
                            			let beginning = ( s:martcs == '' ? '\c' : '\C' ).'^.*'
                            			if s:byfname()
                            				" Make sure there are no slashes in our match
                            				let beginning = beginning.'\([^\/]*$\)\@='
                            			en
                            
                            			for i in range(len(chars))
                            				" Surround our current target letter with \zs and \ze so it only
                            				" actually matches that one letter, but has all preceding and trailing
                            				" letters as well.
                            				" \zsa.*b.*c
                            				" a\(\zsb\|.*\zsb)\ze.*c
                            				let charcopy = copy(chars)
                            				if i == 0
                            					let charcopy[i] = '\zs'.charcopy[i].'\ze'
                            					let middle = join(charcopy, '.\{-}')
                            				el
                            					let before = join(charcopy[0:i-1], '.\{-}')
                            					let after = join(charcopy[i+1:-1], '.\{-}')
                            					let c = charcopy[i]
                            					" for abc, match either ab.\{-}c or a.*b.\{-}c in that order
                            					let cpat = '\(\zs'.c.'\|'.'.*\zs'.c.'\)\ze.*'
                            					let middle = before.cpat.after
                            				en
                            
                            				" Now we matchadd for each letter, the basic form being:
                            				" ^.*\zsx\ze.*$, but with our pattern we built above for the letter,
                            				" and a negative lookahead ensuring that we only highlight the last
                            				" occurrence of our letters. We also ensure that our matcher is case
                            				" insensitive or sensitive depending.
                            				cal matchadd(a:grp, beginning.middle.ending)
                            			endfo
                            		en
                            
                            		cal matchadd('CtrlPLinePre', '^>')
                            	elseif !empty(a:pat) && s:regexp &&
                            				\ exists('g:ctrlp_regex_always_higlight') &&
                            				\ g:ctrlp_regex_always_higlight
                            		let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C').pat)
                            	en
                            endf
                            
    1              0.000002 fu! s:dohighlight()
                            	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()
                            endf
                            " Prompt history {{{2
    1              0.000001 fu! s:gethistloc()
                            	let utilcadir = ctrlp#utils#cachedir()
                            	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
                            	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']
                            endf
                            
    1              0.000001 fu! s:gethistdata()
                            	retu ctrlp#utils#readfile(s:gethistloc()[1])
                            endf
                            
    1              0.000001 fu! ctrlp#recordhist()
                            	let str = join(s:prompt, '')
                            	if empty(str) || !s:maxhst | retu | en
                            	let hst = s:hstry
                            	if len(hst) > 1 && hst[1] == str | retu | en
                            	cal extend(hst, [str], 1)
                            	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
                            	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])
                            endf
                            " Signs {{{2
    1              0.000002 fu! s:unmarksigns()
                            	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo
                            endf
                            
    1              0.000001 fu! s:remarksigns()
                            	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo
                            endf
                            
    1              0.000001 fu! s:dosigns()
                            	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')
                            endf
                            " Lists & Dictionaries {{{2
    1              0.000002 fu! s:ifilter(list, str)
                            	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
                            	for each in a:list
                            		try
                            			if eval(estr)
                            				cal add(rlist, each)
                            			en
                            		cat | con | endt
                            	endfo
                            	retu rlist
                            endf
                            
    1              0.000002 fu! s:dictindex(dict, expr)
                            	for key in keys(a:dict)
                            		if a:dict[key] ==# a:expr | retu key | en
                            	endfo
                            	retu -1
                            endf
                            
    1              0.000002 fu! s:vacantdict(dict)
                            	retu filter(range(1, max(keys(a:dict))), '!has_key(a:dict, v:val)')
                            endf
                            
    1              0.000002 fu! s:sublist(l, s, e)
                            	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)
                            endf
                            
    1              0.000002 fu! s:sublist7071(l, s, e)
                            	let [newlist, id, ae] = [[], a:s, a:e == -1 ? len(a:l) - 1 : a:e]
                            	wh id <= ae
                            		cal add(newlist, get(a:l, id))
                            		let id += 1
                            	endw
                            	retu newlist
                            endf
                            " Buffers {{{2
    1              0.000002 fu! s:buftab(bufnr, md)
                            	for tabnr in range(1, tabpagenr('$'))
                            		if tabpagenr() == tabnr && a:md == 't' | con | en
                            		let buflist = tabpagebuflist(tabnr)
                            		if index(buflist, a:bufnr) >= 0
                            			for winnr in range(1, tabpagewinnr(tabnr, '$'))
                            				if buflist[winnr - 1] == a:bufnr | retu [tabnr, winnr] | en
                            			endfo
                            		en
                            	endfo
                            	retu [0, 0]
                            endf
                            
    1              0.000001 fu! s:bufwins(bufnr)
                            	let winns = 0
                            	for tabnr in range(1, tabpagenr('$'))
                            		let winns += count(tabpagebuflist(tabnr), a:bufnr)
                            	endfo
                            	retu winns
                            endf
                            
    1              0.000001 fu! s:isabs(path)
                            	if (has('win32') || has('win64'))
                            		return a:path =~ '^\([a-zA-Z]:\)\{-}[/\\]'
                            	el
                            		return a:path =~ '^[/\\]'
                            	en
                            endf
                            
    1              0.000002 fu! s:bufnrfilpath(line)
                              if s:isabs(a:line) || a:line =~ '^\~[/\\]' || a:line =~ '^\w\+:\/\/'
                            		let filpath = a:line
                            	el
                            		let filpath = s:dyncwd.s:lash().a:line
                            	en
                            	let filpath = fnamemodify(filpath, ':p')
                            	let bufnr = bufnr('^'.fnameescape(filpath).'$')
                            	if (!filereadable(filpath) && bufnr < 1)
                            		if (a:line =~ '[\/]\?\[\d\+\*No Name\]$')
                            			let bufnr = str2nr(matchstr(a:line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			let filpath = bufnr
                            		els
                            			let bufnr = bufnr(a:line)
                            			retu [bufnr, a:line]
                            		en
                            	en
                            	retu [bufnr, filpath]
                            endf
                            
    1              0.000006 fu! ctrlp#normcmd(cmd, ...)
                            	let buftypes = [ 'quickfix', 'help', 'nofile' ]
                            	if a:0 < 2 && s:nosplit() | retu a:cmd | en
                            	let norwins = filter(range(1, winnr('$')),
                            		\ 'index(buftypes, getbufvar(winbufnr(v:val), "&bt")) == -1 || s:isterminal(winbufnr(v:val))')
                            	for each in norwins
                            		let bufnr = winbufnr(each)
                            		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
                            			let fstemp = each | brea
                            		en
                            	endfo
                            	let norwin = empty(norwins) ? 0 : norwins[0]
                            	if norwin
                            		if index(norwins, winnr()) < 0
                            			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
                            		en
                            		retu a:cmd
                            	en
                            	retu a:0 ? a:1 : 'bo vne'
                            endf
                            
    1              0.000001 fu! ctrlp#modfilecond(w)
                            	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf &&
                            		\ ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )
                            endf
                            
    1              0.000002 fu! s:nosplit()
                            	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0
                            endf
                            
    1              0.000002 fu! s:setupblank()
                            	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
                            	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
                            	if v:version > 702
                            		setl nornu noudf cc=0
                            	en
                            	if s:has_conceal
                            		setl cole=2 cocu=nc
                            	en
                            endf
                            
    1              0.000001 fu! s:leavepre()
                            	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
                            	if !( exists(s:ccex) && !{s:ccex} )
                            		\ && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
                            		cal ctrlp#clra()
                            	en
                            endf
                            
    1              0.000001 fu! s:checkbuf()
                            	if !exists('s:init') && exists('s:bufnr') && s:bufnr > 0
                            		exe s:bufnr.'bw!'
                            	en
                            endf
                            
    1              0.000002 fu! s:iscmdwin()
                            	let [ermsg, v:errmsg] = [v:errmsg, '']
                            	sil! noa winc p
                            	sil! noa winc p
                            	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
                            	retu ermsg =~ '^E11:'
                            endf
                            " Arguments {{{2
    1              0.000002 fu! s:at(str)
                            	if a:str =~ '\v^\@(cd|lc[hd]?|chd).*'
                            		let str = substitute(a:str, '\v^\@(cd|lc[hd]?|chd)\s*', '', '')
                            		if str == '' | retu 1 | en
                            		let str = str =~ '^%:.\+' ? fnamemodify(s:crfile, str[1:]) : str
                            		let path = fnamemodify(expand(str, 1), ':p')
                            		if isdirectory(path)
                            			if path != s:dyncwd
                            				cal ctrlp#setdir(path)
                            				cal ctrlp#setlines()
                            			en
                            			cal ctrlp#recordhist()
                            			cal s:PrtClear()
                            		en
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000001 fu! s:tail()
                            	if exists('s:optail') && !empty('s:optail')
                            		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
                            		retu tailpref.s:optail
                            	en
                            	retu ''
                            endf
                            
    1              0.000001 fu! s:sanstail(str)
                            	let str = s:spi ?
                            		\ substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
                            	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
                            	unl! s:optail
                            	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
                            	en
                            	retu substitute(str, '\\\ze:', '', 'g')
                            endf
                            
    1              0.000002 fu! s:argmaps(md, i)
                            	let roh = [
                            		\ ['Open Multiple Files', '/h[i]dden/[c]lear', ['i', 'c']],
                            		\ ['Create a New File', '/[r]eplace', ['r']],
                            		\ ['Open Selected', '/[r]eplace', ['r', 'd', 'a']],
                            		\ ]
                            	if a:i == 2
                            		if !buflisted(bufnr('^'.fnamemodify(ctrlp#getcline(), ':p').'$'))
                            			let roh[2][1] .= '/h[i]dden'
                            			let roh[2][2] += ['i']
                            		en
                            		if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            			let roh[2][1] .= '/e[x]ternal'
                            			let roh[2][2] += ['x']
                            		en
                            	en
                            	let str = roh[a:i][0].': [t]ab/[v]ertical/[h]orizontal'.roh[a:i][1].'? '
                            	retu s:choices(str, ['t', 'v', 'h'] + roh[a:i][2], 's:argmaps', [a:md, a:i])
                            endf
                            
    1              0.000003 fu! s:insertstr()
                            	let str = 'Insert: c[w]ord/c[f]ile/[s]earch/[v]isual/[c]lipboard/[r]egister? '
                            	retu s:choices(str, ['w', 'f', 's', 'v', 'c', 'r'], 's:insertstr', [])
                            endf
                            
    1              0.000003 fu! s:textdialog(str)
                            	redr | echoh MoreMsg | echon a:str | echoh None
                            	retu nr2char(getchar())
                            endf
                            
    1              0.000004 fu! s:choices(str, choices, func, args)
                            	let char = s:textdialog(a:str)
                            	if index(a:choices, char) >= 0
                            		retu char
                            	elsei char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
                            		cal s:BuildPrompt(0)
                            		retu 'cancel'
                            	elsei char =~# "\<CR>" && a:args != []
                            		retu a:args[0]
                            	en
                            	retu call(a:func, a:args)
                            endf
                            
    1              0.000003 fu! s:getregs()
                            	let char = s:textdialog('Insert from register: ')
                            	if char =~# "\\v\<Esc>|\<C-c>|\<C-g>|\<C-u>|\<C-w>|\<C-[>"
                            		cal s:BuildPrompt(0)
                            		retu -1
                            	elsei char =~# "\<CR>"
                            		retu s:getregs()
                            	en
                            	retu s:regisfilter(char)
                            endf
                            
    1              0.000003 fu! s:regisfilter(reg)
                            	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')
                            endf
                            " Misc {{{2
    1              0.000007 fu! s:modevar()
                            	let s:matchtype = s:mtype()
                            	let s:ispath = s:ispathitem()
                            	let s:mfunc = s:mfunc()
                            	let s:nolim = s:getextvar('nolim')
                            	let s:dosort = s:getextvar('sort')
                            	let s:spi = !s:itemtype || s:getextvar('specinput') > 0
                            endf
                            
    1              0.000002 fu! s:nosort()
                            	let ct = s:curtype()
                            	retu s:matcher != {} || s:nolim == 1 || ( ct == 'mru' && s:mrudef )
                            		\ || ( ct =~ '^\(buf\|mru\)$' && s:prompt == ['', '', ''] ) || !s:dosort
                            endf
                            
    1              0.000002 fu! s:byfname()
                            	retu s:curtype() != 'buf' && s:ispath && s:byfname
                            endf
                            
    1              0.000002 fu! s:narrowable()
                            	retu exists('s:act_add') && exists('s:matched') && s:matched != []
                            		\ && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp]
                            		\ && s:matcher == {} && !exists('s:did_exp')
                            endf
                            
    1              0.000003 fu! s:getinput(...)
                            	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
                            	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 )
                            				\ || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
                            	en
                            	retu spi == 'c' ? prt[0] : join(prt, '')
                            endf
                            
    1              0.000002 fu! s:strwidth(str)
                            	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)
                            endf
                            
    1              0.000002 fu! ctrlp#j2l(nr)
                            	exe 'norm!' a:nr.'G'
                            	sil! norm! zvzz
                            endf
                            
    1              0.000001 fu! s:maxf(len)
                            	retu s:maxfiles && a:len > s:maxfiles
                            endf
                            
    1              0.000005 fu! s:regexfilter(str)
                            	let str = a:str
                            	for key in keys(s:fpats) | if str =~ key
                            		let str = substitute(str, s:fpats[key], '', 'g')
                            	en | endfo
                            	retu str
                            endf
                            
    1              0.000001 fu! s:walker(m, p, d)
                            	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m
                            endf
                            
    1              0.000002 fu! s:delent(rfunc)
                            	if a:rfunc == '' | retu | en
                            	let [s:force, tbrem] = [1, []]
                            	if exists('s:marked')
                            		let tbrem = values(s:marked)
                            		cal s:unmarksigns()
                            		unl s:marked
                            	en
                            	if tbrem == [] && ( has('dialog_gui') || has('dialog_con') ) &&
                            		\ confirm("Wipe all entries?", "&OK\n&Cancel") != 1
                            		unl s:force
                            		cal s:BuildPrompt(0)
                            		retu
                            	en
                            	let g:ctrlp_lines = call(a:rfunc, [tbrem])
                            	cal s:BuildPrompt(1)
                            	unl s:force
                            endf
                            
    1              0.000001 fu! s:delbufcond(bufnr)
                            	retu getbufvar(a:bufnr, "&mod") || a:bufnr == s:crbufnr
                            endf
                            
    1              0.000001 fu! s:delbuf()
                            	let lines = []
                            	if exists('s:marked')
                            		let lines = values(s:marked)
                            		cal s:unmarksigns()
                            		unl s:marked
                            	el
                            		let lines += [ctrlp#getcline()]
                            	en
                            	for line in lines
                            		let bufnr = s:bufnrfilpath(line)[0]
                            		if (s:delbufcond(bufnr))
                            			con
                            		en
                            		exe 'bd '. bufnr
                            	endfo
                            	cal s:PrtClearCache()
                            endf
                            
    1              0.000002 fu! s:isterminal(buf)
                            	retu getbufvar(a:buf, "&bt") == "terminal"
                            endf
                            " Entering & Exiting {{{2
    1              0.000001 fu! s:getenv()
                            	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
                            	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
                            	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
                            	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
                            	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
                            	let s:crfile = bufname('%') == ''
                            		\ ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
                            	let s:crfpath = expand('%:p:h', 1)
                            	let s:mrbs = ctrlp#mrufiles#bufs()
                            endf
                            
    1              0.000002 fu! s:lastvisual()
                            	let cview = winsaveview()
                            	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
                            	let [oureg, outype] = [getreg('"'), getregtype('"')]
                            	sil! norm! gV"vy
                            	let selected = s:regisfilter('v')
                            	cal setreg('v', ovreg, ovtype)
                            	cal setreg('"', oureg, outype)
                            	cal winrestview(cview)
                            	retu selected
                            endf
                            
    1              0.000001 fu! s:log(m)
                            	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
                            	en | en
                            endf
                            
    1              0.000002 fu! s:buffunc(e)
                            	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
                            	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
                            	en
                            endf
                            
    1              0.000003 fu! s:openfile(cmd, fid, tail, chkmod, ...)
                            	let cmd = a:cmd
                            	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
                            		let cmd = cmd == 'b' ? 'sb' : 'sp'
                            	en
                            	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
                            	let j2l = a:0 && a:1[0] ? a:1[1] : 0
                            	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
                            	if j2l
                            		cal ctrlp#j2l(j2l)
                            	en
                            	if !empty(a:tail)
                            		sil! norm! zvzz
                            	en
                            	if cmd != 'bad'
                            		cal ctrlp#setlcdir()
                            	en
                            endf
                            
    1              0.000001 fu! ctrlp#tabcount()
                            	if exists('s:tabct')
                            		let tabct = s:tabct
                            		let s:tabct += 1
                            	elsei !type(s:tabpage)
                            		let tabct = s:tabpage
                            	elsei type(s:tabpage) == 1
                            		let tabpos =
                            			\ s:tabpage =~ 'c' ? tabpagenr() :
                            			\ s:tabpage =~ 'f' ? 1 :
                            			\ s:tabpage =~ 'l' ? tabpagenr('$') :
                            			\ tabpagenr()
                            		let tabct =
                            			\ s:tabpage =~ 'a' ? tabpos :
                            			\ s:tabpage =~ 'b' ? tabpos - 1 :
                            			\ tabpos
                            	en
                            	retu tabct < 0 ? 0 : tabct
                            endf
                            
    1              0.000003 fu! s:settype(type)
                            	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type
                            endf
                            " Matching {{{2
    1              0.000001 fu! s:matchfname(item, pat)
                            	let parts = split(a:item, '[\/]\ze[^\/]\+$')
                            	let mfn = match(parts[-1], a:pat[0])
                            	retu len(a:pat) == 1 ? mfn : len(a:pat) == 2 ?
                            		\ ( mfn >= 0 && ( len(parts) == 2 ? match(parts[0], a:pat[1]) : -1 ) >= 0
                            		\ ? 0 : -1 ) : -1
                            endf
                            
    1              0.000001 fu! s:matchbuf(item, pat)
                            	let bufnr = s:bufnrfilpath(a:item)[0]
                            	let parts = s:bufparts(bufnr)
                            	let item = s:byfname ? parts[2] : bufnr.parts[0].parts[2].s:lash().parts[3]
                            	retu match(item, a:pat)
                            endf
                            
    1              0.000002 fu! s:matchtabs(item, pat)
                            	retu match(split(a:item, '\t\+')[0], a:pat)
                            endf
                            
    1              0.000002 fu! s:matchtabe(item, pat)
                            	retu match(split(a:item, '\t\+[^\t]\+$')[0], a:pat)
                            endf
                            
    1              0.000001 fu! s:buildpat(lst)
                            	let pat = a:lst[0]
                            	if s:matchnatural == 1
                            		for item in range(1, len(a:lst) - 1)
                            			let c = a:lst[item - 1]
                            			let pat .= (c == '/' ? '[^/]\{-}' : '[^'.c.'/]\{-}').a:lst[item]
                            		endfo
                            	els
                            		for item in range(1, len(a:lst) - 1)
                            			let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
                            		endfo
                            	en
                            	retu pat
                            endf
                            
    1              0.000001 fu! s:curtype()
                            	return s:CurTypeName()[1]
                            endf
                            
    1              0.000001 fu! s:mfunc()
                            	let mfunc = 'match'
                            	if s:byfname()
                            		let mfunc = 's:matchfname'
                            	elsei s:curtype() == 'buf'
                            		let mfunc = 's:matchbuf'
                            	elsei s:itemtype >= len(s:coretypes)
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
                            	en
                            	retu mfunc
                            endf
                            
    1              0.000001 fu! s:mmode()
                            	let matchmodes = {
                            		\ 'match': 'full-line',
                            		\ 's:matchfname': 'filename-only',
                            		\ 's:matchbuf': 'full-line',
                            		\ 's:matchtabs': 'first-non-tab',
                            		\ 's:matchtabe': 'until-last-tab',
                            		\ }
                            	retu matchmodes[s:mfunc]
                            endf
                            " Cache {{{2
    1              0.000002 fu! s:writecache(cafile)
                            	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
                            		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
                            		let g:ctrlp_newcache = 0
                            	en
                            endf
                            
    1              0.000002 fu! s:nocache(...)
                            	if !s:caching
                            		retu 1
                            	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
                            	en
                            	retu 0
                            endf
                            
    1              0.000001 fu! s:insertcache(str)
                            	let [data, g:ctrlp_newcache, str] = [g:ctrlp_allfiles, 1, a:str]
                            	if data == [] || strlen(str) <= strlen(data[0])
                            		let pos = 0
                            	elsei strlen(str) >= strlen(data[-1])
                            		let pos = len(data) - 1
                            	el
                            		let pos = 0
                            		for each in data
                            			if strlen(each) > strlen(str) | brea | en
                            			let pos += 1
                            		endfo
                            	en
                            	cal insert(data, str, pos)
                            	cal s:writecache(ctrlp#utils#cachefile())
                            endf
                            " Extensions {{{2
    1              0.000001 fu! s:mtype()
                            	retu s:itemtype >= len(s:coretypes) ? s:getextvar('type') : 'path'
                            endf
                            
    1              0.000001 fu! s:execextvar(key)
                            	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars),
                            			\ 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
                            	en
                            endf
                            
    1              0.000001 fu! s:getextvar(key)
                            	if s:itemtype >= len(s:coretypes) && len(g:ctrlp_ext_vars) > 0
                            		let vars = g:ctrlp_ext_vars[s:itemtype - len(s:coretypes)]
                            		if has_key(vars, a:key)
                            			retu vars[a:key]
                            		en
                            	en
                            	retu get(g:, 'ctrlp_' . s:matchtype . '_' . a:key, -1)
                            endf
                            
    1              0.000001 fu! ctrlp#getcline()
                            	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
                            	retu !empty(s:lines) && !( offset && linenr <= offset )
                            		\ ? s:lines[linenr - 1 - offset] : ''
                            endf
                            
    1              0.000001 fu! ctrlp#getmarkedlist()
                            	retu exists('s:marked') ? values(s:marked) : []
                            endf
                            
    1              0.000001 fu! ctrlp#clearmarkedlist()
                            	let s:marked = {}
                            endf
                            
    1              0.000001 fu! ctrlp#input()
                            	retu s:getinput()
                            endf
                            
    1              0.000004 fu! ctrlp#exit()
                            	cal s:PrtExit()
                            endf
                            
    1              0.000001 fu! ctrlp#prtclear()
                            	cal s:PrtClear()
                            endf
                            
    1              0.000002 fu! ctrlp#switchtype(id)
                            	cal s:ToggleType(a:id - s:itemtype)
                            endf
                            
    1              0.000001 fu! ctrlp#nosy()
                            	retu !( has('syntax') && exists('g:syntax_on') )
                            endf
                            
    1              0.000002 fu! ctrlp#hicheck(grp, defgrp)
                            	if !hlexists(a:grp)
                            		exe 'hi link' a:grp a:defgrp
                            	en
                            endf
                            
    1              0.000001 fu! ctrlp#call(func, ...)
                            	retu call(a:func, a:000)
                            endf
                            
    1              0.000001 fu! ctrlp#getvar(var)
                            	retu {a:var}
                            endf
                            "}}}1
                            " * Initialization {{{1
    1              0.000001 fu! s:setlines_pre(...)
                            	if a:0 | let s:itemtype = a:1 | en
                            	cal s:modevar()
                            	let s:setlines_post_ended = 0
                            	let g:ctrlp_lines = []
                            endf
                            
    1              0.000001 fu! s:setlines_post()
                            	let inits = {'fil': 'ctrlp#files()', 'buf': 'ctrlp#buffers()', 'mru': 'ctrlp#mrufiles#list()'}
                            	let types = map(copy(g:ctrlp_types), 'inits[v:val]')
                            	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
                            	en
                            	let g:ctrlp_lines = eval(types[s:itemtype])
                            	let s:setlines_post_ended = 1
                            endf
                            
    1              0.000003 fu! ctrlp#setlines(...)
                            	cal call('s:setlines_pre', a:000)
                            	cal s:setlines_post()
                            endf
                            
                            " Returns [lname, sname]
    1              0.000001 fu! s:CurTypeName()
                            	if s:itemtype < len(s:coretypes)
                            		return filter(copy(s:coretypes), 'v:val[1]==g:ctrlp_types[s:itemtype]')[0]
                            	el
                            		return [s:getextvar("lname"), s:getextvar('sname')]
                            	en
                            endfu
                            
    1              0.000002 fu! s:ExitIfSingleCandidate()
                            	if len(s:Update(s:prompt[0])) == 1
                            		call s:AcceptSelection('e')
                            		call ctrlp#exit()
                            		return 1
                            	en
                            	return 0
                            endfu
                            
    1              0.000002 fu! s:IsBuiltin()
                            	let builtins = ['tag', 'dir', 'bft', 'rts', 'bkd', 'lns', 'chs', 'mix', 'udo', 'qfx']
                            	let curtype = s:getextvar('sname')
                            	return s:itemtype < len(s:coretypes) || index(builtins, curtype) > -1
                            endfu
                            
    1              0.000002 fu! s:DetectFileType(type, ft)
                            	if s:IsBuiltin() || empty(a:ft) || a:ft ==# 'ctrlp'
                            		retu 'ctrlp'
                            	el
                            		retu 'ctrlp.' . a:ft
                            	en
                            endfu
                            
    1              0.000002 fu! ctrlp#init(type, ...)
                            	if exists('s:init') || s:iscmdwin() | retu | en
                            	let [s:ermsg, v:errmsg] = [v:errmsg, '']
                            	let [s:matches, s:init] = [1, 1]
                            	cal s:Reset(a:0 ? a:1 : {})
                            	noa cal s:Open()
                            	cal s:SetWD(a:0 ? a:1 : {})
                            	cal s:MapNorms()
                            	cal s:MapSpecs()
                            	if empty(g:ctrlp_types) && empty(g:ctrlp_ext_vars)
                            		call ctrlp#exit()
                            		retu
                            	en
                            	if type(a:type) == 0
                            		let type = a:type
                            	el
                            		let type = index(g:ctrlp_types, a:type)
                            		if type == -1
                            			call ctrlp#exit()
                            			retu
                            		en
                            	en
                            	" Fixed issue ctrlpvim/ctrlp.vim#463 : Opening 'ctrlp' in certain modes
                            	" (':CtrlPBufTag', ':CtrlPLine') seems to trigger a partially deffective
                            	" intialisation (for example, syntax highlighting not working as expected).
                            	" Fix: ctrlp#setlines() split in two, as the second part (now in
                            	" s:setlines_post()) seems to need '&filetype', and s:DetectFileType() seems
                            	" to need the first part of the old ctrlp#setlines() (now in
                            	" s:setlines_pre()).
                            	cal s:setlines_pre(s:settype(type))
                            	let &filetype = s:DetectFileType(type, &filetype)
                            	cal s:setlines_post()
                            	cal ctrlp#syntax()
                            	cal s:SetDefTxt()
                            	let curName = s:CurTypeName()
                            	let shouldExitSingle = index(s:opensingle, curName[0])>=0 || index(s:opensingle, curName[1])>=0
                            	if shouldExitSingle && s:ExitIfSingleCandidate()
                            		return 0
                            	en
                            	cal s:BuildPrompt(1)
                            	if s:keyloop | cal s:KeyLoop() | en
                            	retu 1
                            endf
                            
                            " - Events {{{1
    1              0.000001 fu! s:NotifySearch()
                            	let l:cb = s:getextvar('search')
                            	if l:cb != -1
                            		cal eval(l:cb)
                            	en
                            endf
                            
    1              0.000002 fu! ctrlp#update()
                            	cal s:ForceUpdate()
                            endf
                            
                            " - Autocmds {{{1
    1              0.000005 if has('autocmd')
    1              0.000003 	aug CtrlPAug
    1              0.000201 		au!
    1              0.000010 		au BufEnter ControlP cal s:checkbuf()
    1              0.000004 		au BufLeave ControlP noa cal s:Close()
    1              0.000006 		au VimLeavePre * cal s:leavepre()
    1              0.000001 	aug END
    1              0.000001 en
                            
    1              0.000002 fu! s:autocmds()
                            	if !has('autocmd') | retu | en
                            	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
                            	en
                            	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
                            	en
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

FUNCTION  <SNR>3_SynSet()
    Defined: /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/syntax/synload.vim:33
Called 2 times
Total time:   0.025767
 Self time:   0.000819

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000009   syn clear
    2              0.000063   if exists("b:current_syntax")
                                unlet b:current_syntax
    2              0.000002   endif
                            
    2              0.000009   let s = expand("<amatch>")
    2              0.000005   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    2              0.000002   elseif s == "OFF"
                                let s = ""
    2              0.000002   endif
                            
    2              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000023     for name in split(s, '\.')
    2   0.025605   0.000657       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    4              0.000004     endfor
    2              0.000002   endif

FUNCTION  <SNR>21_LocalBrowse()
    Defined: /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/plugin/netrwPlugin.vim:102
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    1              0.000002   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    1              0.000001   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    1              0.000003   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    1              0.000024   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    1              0.000001   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    1              0.000000   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  ctrlp#clr()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:359
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009 	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]

FUNCTION  <SNR>14_savetofile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:88
Called 2 times
Total time:   0.034904
 Self time:   0.000036

count  total (s)   self (s)
    2   0.034903   0.000035 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>38_getinput()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2292
Called 17 times
Total time:   0.001260
 Self time:   0.001260

count  total (s)   self (s)
   17              0.000117 	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
   17              0.000060 	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 ) || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
   17              0.000024 	en
   17              0.000156 	retu spi == 'c' ? prt[0] : join(prt, '')

FUNCTION  <SNR>38_remarksigns()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2007
Called 13 times
Total time:   0.000157
 Self time:   0.000120

count  total (s)   self (s)
   13   0.000152   0.000115 	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo

FUNCTION  ctrlp#utils#cachefile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:38
Called 2 times
Total time:   0.000126
 Self time:   0.000100

count  total (s)   self (s)
    2              0.000012 	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
    2              0.000061 	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
    2   0.000052   0.000026 	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file

FUNCTION  <SNR>38_shortest()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1558
Called 748 times
Total time:   0.005046
 Self time:   0.005046

count  total (s)   self (s)
  748              0.004730 	retu min(map(values(a:lens), 'v:val[0]'))

FUNCTION  <SNR>38_tail()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2189
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000005 	if exists('s:optail') && !empty('s:optail')
                            		let tailpref = s:optail !~ '^\s*+' ? ' +' : ' '
                            		retu tailpref.s:optail
    1              0.000001 	en
    1              0.000001 	retu ''

FUNCTION  <SNR>38_ifilter()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2022
Called 1 time
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
    1              0.000015 	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
    6              0.000010 	for each in a:list
    5              0.000005 		try
    5              0.000155 			if eval(estr)
    1              0.000004 				cal add(rlist, each)
    5              0.000004 			en
    5              0.000008 		cat | con | endt
    6              0.000007 	endfo
    1              0.000002 	retu rlist

FUNCTION  <SNR>38_stop_timer_if_exists()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:478
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003 	if exists('s:timer')
                            		call timer_stop(s:timer)
                            		unlet s:timer
    1              0.000001 	en

FUNCTION  <SNR>38_setlines_pre()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2650
Called 1 time
Total time:   0.000282
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000003 	if a:0 | let s:itemtype = a:1 | en
    1   0.000274   0.000014 	cal s:modevar()
    1              0.000002 	let s:setlines_post_ended = 0
    1              0.000002 	let g:ctrlp_lines = []

FUNCTION  <SNR>38_writecache()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2542
Called 1 time
Total time:   0.021311
 Self time:   0.000064

count  total (s)   self (s)
    1   0.000058   0.000040 	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
    1   0.021244   0.000015 		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
    1              0.000006 		let g:ctrlp_newcache = 0
    1              0.000001 	en

FUNCTION  ctrlp#mrufiles#cachefile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:137
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000012 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    2              0.000002 	en
    2              0.000004 	retu s:cafile

FUNCTION  <SNR>38_InitCustomFuncs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:416
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003 	if s:igntype == 4 && has_key(s:usrign, 'func-init') && s:usrign['func-init'] != ''
                            		exe call(s:usrign['func-init'], [])
    1              0.000001 	en

FUNCTION  ctrlp#utils#globpath()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:74
Called 12 times
Total time:   0.001002
 Self time:   0.001002

count  total (s)   self (s)
   12              0.000959 	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])

FUNCTION  <SNR>38_NotifySearch()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2749
Called 13 times
Total time:   0.000472
 Self time:   0.000235

count  total (s)   self (s)
   13   0.000405   0.000168 	let l:cb = s:getextvar('search')
   13              0.000018 	if l:cb != -1
                            		cal eval(l:cb)
   13              0.000008 	en

FUNCTION  <SNR>38_strwidth()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2318
Called 124 times
Total time:   0.000711
 Self time:   0.000711

count  total (s)   self (s)
  124              0.000663 	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)

FUNCTION  <SNR>38_dosigns()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2018
Called 27 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   27              0.000088 	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')

FUNCTION  <SNR>38_ispathitem()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1740
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008 	retu s:itemtype < len(s:coretypes) || s:getextvar('type') == 'path'

FUNCTION  <SNR>38_isabs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2079
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000008 	if (has('win32') || has('win64'))
                            		return a:path =~ '^\([a-zA-Z]:\)\{-}[/\\]'
    1              0.000000 	el
    1              0.000011 		return a:path =~ '^[/\\]'
                            	en

FUNCTION  ctrlp#utils#opts()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:16
Called 1 time
Total time:   0.000096
 Self time:   0.000066

count  total (s)   self (s)
    1   0.000014   0.000009 	let s:lash = ctrlp#utils#lash()
    1   0.000023   0.000012 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000005 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000039   0.000025 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000003 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
    1              0.000001 	en
    1              0.000002 	let s:cache_dir = cadir

FUNCTION  ctrlp#utils#lash()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:8
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000011 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  <SNR>14_addtomrufs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:70
Called 3 times
Total time:   0.014157
 Self time:   0.000704

count  total (s)   self (s)
    3              0.000115 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    3              0.000024 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    3              0.000031 	let abs_fn = fnamemodify(fn,':p')
    3              0.000371 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
    3              0.000005 	en
    3              0.000035 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    3              0.000003 	if idx
    1              0.000008 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    1              0.000011 		cal insert(s:mrufs, fn)
    1              0.000005 		if {s:soup} && idx < 0
    1   0.013495   0.000042 			cal s:savetofile(s:mergelists())
    1              0.000002 		en
    3              0.000001 	en

FUNCTION  <SNR>38_mtype()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2580
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006 	retu s:itemtype >= len(s:coretypes) ? s:getextvar('type') : 'path'

FUNCTION  <SNR>38_gethistdata()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1986
Called 1 time
Total time:   0.000595
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000592   0.000030 	retu ctrlp#utils#readfile(s:gethistloc()[1])

FUNCTION  <SNR>38_glbpath()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1873
Called 12 times
Total time:   0.001224
 Self time:   0.000222

count  total (s)   self (s)
   12   0.001221   0.000219 	retu call('ctrlp#utils#globpath', a:000)

FUNCTION  <SNR>38_sanstail()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2197
Called 14 times
Total time:   0.001318
 Self time:   0.001318

count  total (s)   self (s)
   14              0.000555 	let str = s:spi ? substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
   14              0.000214 	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
   14              0.000030 	unl! s:optail
   14              0.000226 	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
   14              0.000016 	en
   14              0.000129 	retu substitute(str, '\\\ze:', '', 'g')

FUNCTION  ctrlp#acceptfile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1183
Called 1 time
Total time:   0.074049
 Self time:   0.000279

count  total (s)   self (s)
    1              0.000001 	let useb = 0
    1              0.000004 	if a:0 == 1 && type(a:1) == 4
    1              0.000006 		let [md, line] = [a:1['action'], a:1['line']]
    1              0.000004 		let atl = has_key(a:1, 'tail') ? a:1['tail'] : ''
                            	el
                            		let [md, line] = [a:1, a:2]
                            		let atl = a:0 > 2 ? a:3 : ''
    1              0.000000 	en
    1              0.000003 	if !type(line)
                            		let [filpath, bufnr, useb] = [line, line, 1]
    1              0.000001 	el
    1   0.000497   0.000020 		let [bufnr, filpath] = s:bufnrfilpath(line)
    1              0.000002 		if bufnr == filpath
                            			let useb = 1
    1              0.000001 		en
    1              0.000000 	en
    1   0.022343   0.000015 	cal s:PrtExit()
    1   0.000027   0.000015 	let tail = s:tail()
    1              0.000013 	let j2l = atl != '' ? atl : matchstr(tail, '^ +\zs\d\+$')
    1              0.000006 	let openmyself = bufnr == bufnr('%')
    1              0.000005 	if bufnr > 0 && ( !empty(s:jmptobuf) && s:jmptobuf =~ md ) && !( md == 'e' && openmyself )
                            		let [jmpb, bufwinnr] = [1, bufwinnr(bufnr)]
                            		let buftab = ( s:jmptobuf =~# '[tTVH]' || s:jmptobuf > 1 ) ? s:buftab(bufnr, md) : [0, 0]
    1              0.000001 	en
                            	" Switch to existing buffer or open new one
    1              0.000006 	if exists('jmpb') && bufwinnr > 0 && !( md == 't' && ( s:jmptobuf !~# toupper(md) || buftab[0] ) )
                            		exe bufwinnr.'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
    1              0.000004 	elsei exists('jmpb') && buftab[0] && !( md =~ '[evh]' && s:jmptobuf !~# toupper(md) )
                            		exe 'tabn' buftab[0]
                            		exe buftab[1].'winc w'
                            		if j2l | cal ctrlp#j2l(j2l) | en
    1              0.000001 	el
                            		" Determine the command to use
    1              0.000004 		let useb = bufnr > 0 && ( buflisted(bufnr) || openmyself ) && ( empty(tail) || useb )
    1   0.000242   0.000045 		let cmd = md == 't' || s:splitwin == 1 ? ( useb ? 'tab sb' : 'tabe' ) : md == 'h' || s:splitwin == 2 ? ( useb ? 'sb' : 'new' ) : md == 'v' || s:splitwin == 3 ? ( useb ? 'vert sb' : 'vne' ) : &bt == 'help' && openmyself ? 'b' : call('ctrlp#normcmd', useb ? ['b', 'bo vert sb'] : ['e'])
                            		" Reset &switchbuf option
    1              0.000015 		let [swb, &swb] = [&swb, '']
                            		" Open new window/buffer
    1              0.000007 		let [fid, tail] = [( useb ? bufnr : filpath ), ( atl != '' ? ' +'.atl : tail )]
    1              0.000004 		let args = [cmd, fid, tail, 1, [useb, j2l]]
    1   0.050792   0.000036 		cal call('s:openfile', args)
    1              0.000019 		let &swb = swb
    1              0.000001 	en

FUNCTION  <SNR>38_match_window_opts()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:286
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000010 	let s:mw_pos = s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') : exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' ) : 'bottom'
    1              0.000008 	let s:mw_order = s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') : exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' ) : 'btt'
    1              0.000007 	let s:mw_max = s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) : exists('g:ctrlp_max_height') ? s:mxheight : 10
    1              0.000005 	let s:mw_min = s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
    1              0.000007 	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
    1              0.000003 	let s:mw_min = min([s:mw_min, s:mw_max])
    1              0.000008 	let s:mw_res = s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+')) : min([s:mw_max, &lines])

FUNCTION  <SNR>38_settype()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2470
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003 	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type

FUNCTION  <SNR>38_autocmds()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2770
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003 	if !has('autocmd') | retu | en
    1              0.000003 	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
    1              0.000001 	en
    1              0.000001 	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
    1              0.000000 	en

FUNCTION  <SNR>38_Close()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:332
Called 1 time
Total time:   0.022267
 Self time:   0.000677

count  total (s)   self (s)
    1   0.000266   0.000016 	cal s:async_glob_abort()
    1   0.000028   0.000016 	cal s:buffunc(0)
    1              0.000003 	if winnr('$') == 1
                            		bw!
    1              0.000001 	el
    1              0.000147 		try | bun!
    1              0.000005 		cat | clo! | endt
    1   0.000037   0.000018 		cal s:unmarksigns()
    1              0.000001 	en
   34              0.000093 	for key in keys(s:glbs) | if exists('+'.key)
   16              0.000149 		sil! exe 'let &'.key.' = s:glb_'.key
   34              0.000033 	en | endfo
    1              0.000004 	if exists('s:glb_acd') | let &acd = s:glb_acd | en
    1              0.000002 	let g:ctrlp_lines = []
    1              0.000005 	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
    1              0.000010 		exe s:winres[0].s:winres[0]
    1              0.000001 	en
    1              0.000012 	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:init s:savestr s:mrbs s:did_exp
    1   0.021282   0.000016 	cal ctrlp#recordhist()
    1   0.000102   0.000083 	cal s:execextvar('exit')
    1   0.000042   0.000018 	cal s:log(0)
    1              0.000005 	let v:errmsg = s:ermsg
    1              0.000023 	ec

FUNCTION  <SNR>38_leavepre()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2148
Called 1 time
Total time:   0.001817
 Self time:   0.000307

count  total (s)   self (s)
    1              0.000179 	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
    1              0.000025 	if !( exists(s:ccex) && !{s:ccex} ) && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
    1   0.001575   0.000065 		cal ctrlp#clra()
    1              0.000001 	en

FUNCTION  <SNR>38_SpecInputs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1239
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000011 	if a:str =~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*)$' && s:spi
                            		let cwd = s:dyncwd
                            		cal ctrlp#setdir(a:str =~ '^\.\.\.*$' ? '../'.repeat('../', strlen(a:str) - 2) : a:str)
                            		if cwd != s:dyncwd | cal ctrlp#setlines() | en
                            		cal s:PrtClear()
                            		retu 1
    1              0.000003 	elsei a:str == s:lash && s:spi
                            		cal s:SetWD({ 'mode': 'rd' })
                            		cal ctrlp#setlines()
                            		cal s:PrtClear()
                            		retu 1
    1              0.000005 	elsei a:str =~ '^@.\+' && s:spi
                            		retu s:at(a:str)
    1              0.000002 	elsei a:str == '?'
                            		cal s:PrtExit()
                            		let hlpwin = &columns > 159 ? '| vert res 80' : ''
                            		sil! exe 'bo vert h ctrlp-mappings' hlpwin '| norm! 0'
                            		retu 1
    1              0.000001 	en
    1              0.000001 	retu 0

FUNCTION  <SNR>38_async_glob_abort()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:472
Called 1 time
Total time:   0.000250
 Self time:   0.000052

count  total (s)   self (s)
    1   0.000029   0.000016 	cal s:stop_job_if_exists()
    1   0.000026   0.000019 	cal s:stop_timer_if_exists()
    1   0.000194   0.000016 	cal s:ForceUpdate()

FUNCTION  <SNR>38_iscmdwin()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2162
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000006 	let [ermsg, v:errmsg] = [v:errmsg, '']
    1              0.000009 	sil! noa winc p
    1              0.000004 	sil! noa winc p
    1              0.000004 	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
    1              0.000005 	retu ermsg =~ '^E11:'

FUNCTION  <SNR>38_lsCmd()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:561
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000001 	let cmd = s:usrcmd
    1              0.000002 	if type(cmd) == 1
    1              0.000001 		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                            		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
                            		let s:vcscmd = s:lash == '\'
                            		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en

FUNCTION  ctrlp#utils#cachedir()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:34
Called 5 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    5              0.000013 	retu s:cache_dir

FUNCTION  ctrlp#complen()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1485
Called 2918 times
Total time:   0.016649
 Self time:   0.016649

count  total (s)   self (s)
                            	" By length
 2918              0.010318 	let [len1, len2] = [strlen(a:1), strlen(a:2)]
 2918              0.004147 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  <SNR>38_byfname()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2282
Called 64 times
Total time:   0.003481
 Self time:   0.000953

count  total (s)   self (s)
   64   0.003448   0.000920 	retu s:curtype() != 'buf' && s:ispath && s:byfname

FUNCTION  htmlcomplete#DetectOmniFlavor()
    Defined: /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/autoload/htmlcomplete.vim:9
Called 1 time
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    1              0.000001   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
    1              0.000000   else
    1              0.000001     let b:html_omni_flavor = 'html401t'
    1              0.000001   endif
    1              0.000001   let i = 1
    1              0.000001   let line = ""
   10              0.000015   while i < 10 && i < line("$")
    9              0.000016     let line = getline(i)
    9              0.000028     if line =~ '<!DOCTYPE.*\<DTD '
                                  break
    9              0.000004     endif
    9              0.000005     let i += 1
   10              0.000008   endwhile
    1              0.000003   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
    1              0.000000   endif

FUNCTION  <SNR>38_CloseCustomFuncs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:422
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004 	if s:igntype == 4 && has_key(s:usrign, 'func-close') && s:usrign['func-close'] != ''
                            		exe call(s:usrign['func-close'], [])
    1              0.000001 	en

FUNCTION  <SNR>38_log()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2413
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000011 	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
    2              0.000003 	en | en

FUNCTION  <SNR>38_buffunc()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2423
Called 2 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000009 	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
    2              0.000007 	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
    2              0.000001 	en

FUNCTION  <SNR>38_ForceUpdate()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:761
Called 1 time
Total time:   0.000178
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000008 	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
    1   0.000166   0.000023 	sil! cal s:Update(escape(s:getinput(), '\'))
    1              0.000004 	cal setpos('.', pos)

FUNCTION  <SNR>38_Render()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:703
Called 13 times
Total time:   0.276676
 Self time:   0.009638

count  total (s)   self (s)
   13              0.000256 	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
   13              0.000102 	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
   13   0.000866   0.000214 	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
   13              0.000071 	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            
                            	" Setup the match window
   13              0.000399 	sil! exe '%d _ | res' height
                            	" Print the new items
   13              0.000051 	if empty(lines)
                            		let [s:matched, s:lines] = [[], []]
                            		let lines = [' == NO ENTRIES ==']
                            		cal setline(1, s:offset(lines, height - 1))
                            		setl noma nocul
                            		exe cur_cmd
                            		cal s:unmarksigns()
                            		if s:dohighlight() | cal clearmatches() | en
                            		retu
   13              0.000011 	en
   13              0.000170 	let s:matched = copy(lines)
                            	" Sorting
   13   0.001144   0.000230 	if !s:nosort()
   13              0.000046 		let s:compat = s:martcs.pat
   13   0.258189   0.005103 		cal sort(lines, 's:mixedsort')
   13              0.000021 		unl s:compat
   13              0.000011 	en
   13              0.000074 	if s:mw_order == 'btt' | cal reverse(lines) | en
   13              0.000079 	let s:lines = copy(lines)
   13   0.010314   0.001249 	cal map(lines, s:flfunc)
   13   0.000337   0.000248 	cal setline(1, s:offset(lines, height))
   13   0.000338   0.000164 	cal s:unmarksigns()
   13   0.000270   0.000113 	cal s:remarksigns()
                            	" Highlighting
   13   0.000341   0.000138 	if s:dohighlight()
   13   0.002864   0.000166 		cal s:highlight(pat, s:mathi[1])
   13              0.000009 	en
   13              0.000163 	setl noma cul
   13              0.000181 	exe cur_cmd

FUNCTION  <SNR>38_compfnlen()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1537
Called 374 times
Total time:   0.007188
 Self time:   0.007188

count  total (s)   self (s)
                            	" By filename length
  374              0.003505 	let len1 = strlen(split(a:1, s:lash)[-1])
  374              0.002551 	let len2 = strlen(split(a:2, s:lash)[-1])
  374              0.000715 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  ctrlp#hicheck()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2635
Called 17 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
   17              0.000110 	if !hlexists(a:grp)
   17              0.000169 		exe 'hi link' a:grp a:defgrp
   17              0.000013 	en

FUNCTION  ctrlp#utils#writecache()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:63
Called 4 times
Total time:   0.077000
 Self time:   0.076826

count  total (s)   self (s)
    4   0.000211   0.000099 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    4   0.076757   0.076695 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    4              0.000019 	en

FUNCTION  <SNR>7_LoadIndent()
    Defined: /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/indent.vim:13
Called 2 times
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
    2              0.000006     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    2              0.000001     endif
    2              0.000005     let s = expand("<amatch>")
    2              0.000002     if s != ""
    2              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000015       for name in split(s, '\.')
    2              0.000144 	exe 'runtime! indent/' . name . '.vim'
    4              0.000004       endfor
    2              0.000000     endif

FUNCTION  <SNR>38_getextvar()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2591
Called 29 times
Total time:   0.000592
 Self time:   0.000592

count  total (s)   self (s)
   29              0.000143 	if s:itemtype >= len(s:coretypes) && len(g:ctrlp_ext_vars) > 0
                            		let vars = g:ctrlp_ext_vars[s:itemtype - len(s:coretypes)]
                            		if has_key(vars, a:key)
                            			retu vars[a:key]
                            		en
   29              0.000020 	en
   29              0.000178 	retu get(g:, 'ctrlp_' . s:matchtype . '_' . a:key, -1)

FUNCTION  <SNR>38_AcceptSelection()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1263
Called 1 time
Total time:   0.074332
 Self time:   0.000151

count  total (s)   self (s)
    1              0.000023 	let [md, icr] = [a:action[0], match(a:action, 'r') >= 0]
    1              0.000004 	let subm = icr || ( !icr && md == 'e' )
    1              0.000007 	if !subm && s:OpenMulti(md) != -1 | retu | en
    1   0.000075   0.000013 	let str = s:getinput()
    1   0.000070   0.000016 	if subm | if s:SpecInputs(str) | retu | en | en
                            	" Get the selected line
    1   0.000031   0.000015 	let line = ctrlp#getcline()
    1              0.000005 	if !subm && s:curtype() != 'fil' && line == '' && line('.') > s:offset && str !~ '\v^(\.\.([\/]\.\.)*[\/]?[.\/]*|/|\\|\?|\@.+)$'
                            		cal s:CreateNewFile(md) | retu
    1              0.000001 	en
    1              0.000003 	if empty(line) | retu | en
                            	" Do something with it
    1              0.000004 	if s:openfunc != {} && has_key(s:openfunc, s:ctype)
                            		let actfunc = s:openfunc[s:ctype]
                            		let type = has_key(s:openfunc, 'arg_type') ? s:openfunc['arg_type'] : 'list'
    1              0.000001 	el
    1              0.000003 		if s:itemtype < len(s:coretypes)
    1              0.000005 			let [actfunc, type] = ['ctrlp#acceptfile', 'dict']
                            		el
                            			let [actfunc, exttype] = [s:getextvar('accept'), s:getextvar('act_farg')]
                            			let type = exttype == 'dict' ? exttype : 'list'
    1              0.000001 		en
    1              0.000001 	en
    1              0.000008 	let actargs = type == 'dict' ? [{ 'action': md, 'line': line, 'icr': icr, 'input': str}] : [md, line]
    1   0.074073   0.000024 	cal call(actfunc, actargs)

FUNCTION  <SNR>38_dohighlight()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1976
Called 13 times
Total time:   0.000203
 Self time:   0.000130

count  total (s)   self (s)
   13   0.000197   0.000124 	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()

FUNCTION  <SNR>38_nosort()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2276
Called 13 times
Total time:   0.000914
 Self time:   0.000363

count  total (s)   self (s)
   13   0.000720   0.000169 	let ct = s:curtype()
   13              0.000178 	retu s:matcher != {} || s:nolim == 1 || ( ct == 'mru' && s:mrudef ) || ( ct =~ '^\(buf\|mru\)$' && s:prompt == ['', '', ''] ) || !s:dosort

FUNCTION  <SNR>38_Open()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:309
Called 1 time
Total time:   0.003802
 Self time:   0.002258

count  total (s)   self (s)
    1   0.000027   0.000009 	cal s:log(1)
    1   0.000384   0.000010 	cal s:getenv()
    1   0.000030   0.000018 	cal s:execextvar('enter')
    1              0.000947 	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
    1   0.000040   0.000023 	cal s:buffunc(1)
    1              0.000008 	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
    1              0.000004 	let [s:focus, s:prompt] = [1, ['', '', '']]
    1              0.000001 	abc <buffer>
    1              0.000002 	if !exists('s:hstry')
    1   0.001260   0.000595 		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
    1              0.000004 		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
    1              0.000001 	en
   34              0.000168 	for [ke, va] in items(s:glbs) | if exists('+'.ke)
   16              0.000328 		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
   34              0.000047 	en | endfo
    1              0.000007 	if s:opmul != '0' && has('signs')
    1              0.000031 		sign define ctrlpmark text=+> texthl=CtrlPMark
    1              0.000007 		hi def link CtrlPMark Search
    1              0.000001 	en
    1   0.000482   0.000024 	cal s:setupblank()

FUNCTION  <SNR>38_curtype()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2512
Called 577 times
Total time:   0.017178
 Self time:   0.007625

count  total (s)   self (s)
  577   0.016946   0.007393 	return s:CurTypeName()[1]

FUNCTION  <SNR>38_PrtBS()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:824
Called 3 times
Total time:   0.074637
 Self time:   0.000219

count  total (s)   self (s)
    3              0.000026 	if !s:focus | retu | en
    3              0.000032 	if empty(s:prompt[0]) && s:brfprt != 0
                            		cal s:PrtExit()
                            		retu
    3              0.000003 	en
    3              0.000006 	unl! s:hstgot
    3              0.000071 	let [s:prompt[0], s:matches] = [substitute(s:prompt[0], '.$', '', ''), 1]
    3   0.074480   0.000062 	cal s:BuildPrompt(1)

FUNCTION  <SNR>38_compmatlen()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1491
Called 374 times
Total time:   0.083941
 Self time:   0.018696

count  total (s)   self (s)
                            	" By match length
  374   0.042075   0.008722 	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
  374   0.040664   0.008772 	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
  374              0.000767 	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1

FUNCTION  <SNR>38_maxf()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2327
Called 12 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
   12              0.000025 	retu s:maxfiles && a:len > s:maxfiles

FUNCTION  <SNR>38_MatchedItems()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:645
Called 13 times
Total time:   0.039640
 Self time:   0.001884

count  total (s)   self (s)
   13              0.000074 	let exc = exists('s:crfilerel') ? s:crfilerel : ''
   13   0.001025   0.000793 	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
   13   0.000531   0.000219 	let matcher = s:getextvar('matcher')
   13              0.000080 	if empty(matcher) || type(matcher) != 4 || !has_key(matcher, 'match')
   13              0.000023 		unlet matcher
   13              0.000029 		let matcher = s:matcher
   13              0.000009 	en
   13              0.000028 	if matcher != {}
                            		let argms = has_key(matcher, 'arg_type') && matcher['arg_type'] == 'dict' ? [{ 'items':  items, 'str':    a:pat, 'limit':  a:limit, 'mmode':  s:mmode(), 'ispath': s:ispath, 'crfile': exc, 'regex':  s:regexp, }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(matcher['match'], argms, matcher)
   13              0.000015 	el
   13   0.037492   0.000280 		let lines = s:MatchIt(items, a:pat, a:limit, exc)
   13              0.000013 	en
   13              0.000040 	let s:matches = len(lines)
   13              0.000020 	unl! s:did_exp
   13              0.000011 	retu lines

FUNCTION  <SNR>38_DetectFileType()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2696
Called 1 time
Total time:   0.000043
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000042   0.000014 	if s:IsBuiltin() || empty(a:ft) || a:ft ==# 'ctrlp'
    1              0.000001 		retu 'ctrlp'
                            	el
                            		retu 'ctrlp.' . a:ft
                            	en

FUNCTION  <SNR>38_PrtFocusMap()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:982
Called 9 times
Total time:   0.268226
 Self time:   0.000375

count  total (s)   self (s)
    9   0.268197   0.000346 	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])

FUNCTION  <SNR>38_GlobPath()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:428
Called 13 times
Total time:   1.111859
 Self time:   0.008508

count  total (s)   self (s)
   13              0.070941 	let entries = split(globpath(a:dirs, s:glob), "\n")
   13   0.114152   0.000287 	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
   13              0.000132 	cal extend(g:ctrlp_allfiles, dnf[1])
   13   0.000182   0.000152 	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
   12   0.019137   0.000156 		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
   12   0.008408   0.001537 		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
   13              0.000007 	en

FUNCTION  <SNR>38_sublist()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2045
Called 13 times
Total time:   0.000714
 Self time:   0.000714

count  total (s)   self (s)
   13              0.000700 	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)

FUNCTION  ctrlp#dirnfile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1749
Called 13 times
Total time:   0.113865
 Self time:   0.026577

count  total (s)   self (s)
   13   0.000525   0.000225 	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
  531              0.000736 	for each in a:entries
  518              0.006797 		let etype = getftype(each)
 1023   0.093983   0.006995 		if s:igntype >= 0 && s:usrign(each, etype) | con | en
  420              0.000585 		if etype == 'dir'
   96              0.000110 			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                            				cal add(items[0], each)
   96              0.000064 			en | el
   96              0.000360 				cal add(items[0], each)
   96              0.000056 			en
  324              0.000446 		elsei etype == 'link'
                            			if s:folsym
                            				let isfile = !isdirectory(each)
                            				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                            					cal add(items[isfile], each)
                            				en
                            			en
  324              0.000372 		elsei etype == 'file'
  324              0.001197 			cal add(items[1], each)
  420              0.000259 		en
  433              0.001198 	endfo
   13              0.000014 	retu items

FUNCTION  <SNR>38_BuildPrompt()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:767
Called 15 times
Total time:   0.364751
 Self time:   0.036658

count  total (s)   self (s)
   15   0.001254   0.000379 	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
   15   0.001443   0.000303 	let str = escape(s:getinput(), '\')
   15              0.000147 	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
   15              0.000096 	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp') || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
   13   0.324218   0.000273 		sil! cal s:Update(str)
   15              0.000009 	en
   15   0.001874   0.000213 	sil! cal ctrlp#statusline()
                            	" Toggling
   15              0.000096 	let [hiactive, hicursor, base] = s:focus ? ['CtrlPPrtText', 'CtrlPPrtCursor', base] : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
   15              0.000018 	let hibase = 'CtrlPPrtBase'
                            	" Build it
   15              0.033625 	redr
   15              0.000132 	let prt = copy(s:prompt)
   15              0.000177 	cal map(prt, 'escape(v:val, ''"\'')')
   15              0.000570 	exe 'echoh' hibase '| echon "'.base.'" | echoh' hiactive '| echon "'.prt[0].'" | echoh' hicursor '| echon "'.prt[1].'" | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
   15              0.000056 	if empty(prt[1]) && s:focus
   15              0.000144 		exe 'echoh' hibase '| echon "_" | echoh None'
   15              0.000014 	en
   15              0.000019 	if a:upd
   13   0.000697   0.000225 		cal s:NotifySearch()
   15              0.000010 	en

FUNCTION  <SNR>38_SetDefTxt()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:798
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt

FUNCTION  ctrlp#init()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2704
Called 1 time
Total time:   0.299504
 Self time:   0.000320

count  total (s)   self (s)
    1   0.000045   0.000016 	if exists('s:init') || s:iscmdwin() | retu | en
    1              0.000004 	let [s:ermsg, v:errmsg] = [v:errmsg, '']
    1              0.000003 	let [s:matches, s:init] = [1, 1]
    1   0.000830   0.000011 	cal s:Reset(a:0 ? a:1 : {})
    1   0.003820   0.000018 	noa cal s:Open()
    1   0.002705   0.000034 	cal s:SetWD(a:0 ? a:1 : {})
    1   0.001707   0.000022 	cal s:MapNorms()
    1   0.001072   0.000017 	cal s:MapSpecs()
    1              0.000004 	if empty(g:ctrlp_types) && empty(g:ctrlp_ext_vars)
                            		call ctrlp#exit()
                            		retu
    1              0.000000 	en
    1              0.000003 	if type(a:type) == 0
    1              0.000001 		let type = a:type
                            	el
                            		let type = index(g:ctrlp_types, a:type)
                            		if type == -1
                            			call ctrlp#exit()
                            			retu
                            		en
    1              0.000000 	en
                            	" Fixed issue ctrlpvim/ctrlp.vim#463 : Opening 'ctrlp' in certain modes
                            	" (':CtrlPBufTag', ':CtrlPLine') seems to trigger a partially deffective
                            	" intialisation (for example, syntax highlighting not working as expected).
                            	" Fix: ctrlp#setlines() split in two, as the second part (now in
                            	" s:setlines_post()) seems to need '&filetype', and s:DetectFileType() seems
                            	" to need the first part of the old ctrlp#setlines() (now in
                            	" s:setlines_pre()).
    1   0.000307   0.000021 	cal s:setlines_pre(s:settype(type))
    1   0.001224   0.000020 	let &filetype = s:DetectFileType(type, &filetype)
    1   0.265761   0.000018 	cal s:setlines_post()
    1   0.001497   0.000031 	cal ctrlp#syntax()
    1   0.000024   0.000017 	cal s:SetDefTxt()
    1   0.000043   0.000020 	let curName = s:CurTypeName()
    1              0.000010 	let shouldExitSingle = index(s:opensingle, curName[0])>=0 || index(s:opensingle, curName[1])>=0
    1              0.000004 	if shouldExitSingle && s:ExitIfSingleCandidate()
                            		return 0
    1              0.000001 	en
    1   0.020417   0.000023 	cal s:BuildPrompt(1)
    1              0.000003 	if s:keyloop | cal s:KeyLoop() | en
    1              0.000001 	retu 1

FUNCTION  ctrlp#normcmd()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2107
Called 1 time
Total time:   0.000197
 Self time:   0.000169

count  total (s)   self (s)
    1              0.000006 	let buftypes = [ 'quickfix', 'help', 'nofile' ]
    1   0.000048   0.000020 	if a:0 < 2 && s:nosplit() | retu a:cmd | en
    1              0.000063 	let norwins = filter(range(1, winnr('$')), 'index(buftypes, getbufvar(winbufnr(v:val), "&bt")) == -1 || s:isterminal(winbufnr(v:val))')
    2              0.000009 	for each in norwins
    1              0.000006 		let bufnr = winbufnr(each)
    1              0.000010 		if empty(bufname(bufnr)) && empty(getbufvar(bufnr, '&ft'))
                            			let fstemp = each | brea
    1              0.000001 		en
    2              0.000005 	endfo
    1              0.000008 	let norwin = empty(norwins) ? 0 : norwins[0]
    1              0.000001 	if norwin
    1              0.000005 		if index(norwins, winnr()) < 0
                            			exe ( exists('fstemp') ? fstemp : norwin ).'winc w'
    1              0.000001 		en
    1              0.000002 		retu a:cmd
                            	en
                            	retu a:0 ? a:1 : 'bo vne'

FUNCTION  ctrlp#setdir()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1867
Called 2 times
Total time:   0.000528
 Self time:   0.000359

count  total (s)   self (s)
    2              0.000008 	let cmd = a:0 ? a:1 : 'lc!'
    2   0.000374   0.000205 	sil! exe cmd s:fnesc(a:path, 'c')
    2              0.000140 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]

FUNCTION  <SNR>38_bufnrfilpath()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2087
Called 1 time
Total time:   0.000477
 Self time:   0.000438

count  total (s)   self (s)
    1   0.000047   0.000025   if s:isabs(a:line) || a:line =~ '^\~[/\\]' || a:line =~ '^\w\+:\/\/'
                            		let filpath = a:line
    1              0.000000 	el
    1   0.000031   0.000014 		let filpath = s:dyncwd.s:lash().a:line
    1              0.000001 	en
    1              0.000054 	let filpath = fnamemodify(filpath, ':p')
    1              0.000281 	let bufnr = bufnr('^'.fnameescape(filpath).'$')
    1              0.000041 	if (!filereadable(filpath) && bufnr < 1)
                            		if (a:line =~ '[\/]\?\[\d\+\*No Name\]$')
                            			let bufnr = str2nr(matchstr(a:line, '[\/]\?\[\zs\d\+\ze\*No Name\]$'))
                            			let filpath = bufnr
                            		els
                            			let bufnr = bufnr(a:line)
                            			retu [bufnr, a:line]
                            		en
    1              0.000001 	en
    1              0.000003 	retu [bufnr, filpath]

FUNCTION  <SNR>14_chop()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:38
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000017 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    2              0.000002 	retu a:mrufs

FUNCTION  <SNR>38_comptime()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1498
Called 374 times
Total time:   0.007932
 Self time:   0.007932

count  total (s)   self (s)
                            	" By last modified time
  374              0.006580 	let [time1, time2] = [getftime(a:1), getftime(a:2)]
  374              0.000957 	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1

FUNCTION  <SNR>38_getenv()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2389
Called 1 time
Total time:   0.000374
 Self time:   0.000249

count  total (s)   self (s)
    1              0.000059 	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
    1              0.000014 	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
    1              0.000011 	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
    1              0.000012 	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
    1   0.000153   0.000031 	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
    1              0.000061 	let s:crfile = bufname('%') == '' ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
    1              0.000037 	let s:crfpath = expand('%:p:h', 1)
    1   0.000026   0.000023 	let s:mrbs = ctrlp#mrufiles#bufs()

FUNCTION  <SNR>38_modevar()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2267
Called 1 time
Total time:   0.000260
 Self time:   0.000085

count  total (s)   self (s)
    1   0.000019   0.000011 	let s:matchtype = s:mtype()
    1   0.000040   0.000032 	let s:ispath = s:ispathitem()
    1   0.000142   0.000014 	let s:mfunc = s:mfunc()
    1   0.000031   0.000012 	let s:nolim = s:getextvar('nolim')
    1   0.000024   0.000012 	let s:dosort = s:getextvar('sort')
    1              0.000003 	let s:spi = !s:itemtype || s:getextvar('specinput') > 0

FUNCTION  ctrlp#utils#glob()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:69
Called 1 time
Total time:   0.000065
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000047   0.000009 	let path = ctrlp#utils#fnesc(a:1, 'g')
    1              0.000018 	retu s:wig_cond ? glob(path, a:2) : glob(path)

FUNCTION  <SNR>38_gethistloc()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1980
Called 4 times
Total time:   0.000323
 Self time:   0.000174

count  total (s)   self (s)
    4   0.000082   0.000069 	let utilcadir = ctrlp#utils#cachedir()
    4   0.000126   0.000054 	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
    4   0.000113   0.000049 	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']

FUNCTION  <SNR>38_walker()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2339
Called 30 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   30              0.000115 	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m

FUNCTION  <SNR>38_getparent()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1815
Called 750 times
Total time:   0.048100
 Self time:   0.048100

count  total (s)   self (s)
  750              0.040324 	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
  750              0.004731 	if parent == '' || parent !~ '[\/]'
                            		let parent .= s:lash
  750              0.000545 	en
  750              0.000790 	retu parent

FUNCTION  <SNR>38_narrowable()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2286
Called 13 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
   13              0.000219 	retu exists('s:act_add') && exists('s:matched') && s:matched != [] && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp] && s:matcher == {} && !exists('s:did_exp')

FUNCTION  ctrlp#nosy()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2631
Called 14 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
   14              0.000078 	retu !( has('syntax') && exists('g:syntax_on') )

FUNCTION  <SNR>38_findroot()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1823
Called 3 times
Total time:   0.004291
 Self time:   0.001018

count  total (s)   self (s)
    3              0.000014 	let [depth, fnd] = [a:depth + 1, 0]
    3              0.000007 	if type(a:mark) == 1
                            		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
    3              0.000006 	elsei type(a:mark) == 3
   13              0.000027 		for markr in a:mark
   11   0.001915   0.000400 			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
    1              0.000002 				let fnd = 1
    1              0.000001 				brea
   10              0.000006 			en
   13              0.000012 		endfo
    3              0.000002 	en
    3              0.000003 	if fnd
    1   0.000212   0.000012 		if !a:type | cal ctrlp#setdir(a:curr) | en
    1              0.000004 		retu [exists('markr') ? markr : a:mark, a:curr]
    2              0.000003 	elsei depth > s:maxdepth
                            		cal ctrlp#setdir(s:cwd)
    2              0.000001 	el
    2   0.000155   0.000026 		let parent = s:getparent(a:curr)
    2              0.000005 		if parent != a:curr
    2              0.000009 			retu s:findroot(parent, a:mark, depth, a:type)
                            		en
                            	en
                            	retu []

FUNCTION  <SNR>38_nocache()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2549
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000001 	if !s:caching
                            		retu 1
    1              0.000002 	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
    1              0.000001 	en
    1              0.000001 	retu 0

FUNCTION  <SNR>38_MapNorms()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1046
Called 1 time
Total time:   0.001685
 Self time:   0.001685

count  total (s)   self (s)
    1              0.000004 	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
    1              0.000007 	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
    1              0.000009 	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
    1              0.000001 	let pfunc = 'PrtFocusMap'
    1              0.000038 	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
    4              0.000005 	for each in [34, 92, 124]
    3              0.000069 		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
    4              0.000008 	endfo
   93              0.000067 	for each in ranges
   92              0.001093 		exe printf(cmd, each, pfunc, nr2char(each))
   93              0.000064 	endfo
   11              0.000017 	for each in range(0, 9)
   10              0.000180 		exe printf(pcmd, each, pfunc, each)
   11              0.000016 	endfo
    6              0.000016 	for [ke, va] in items(s:kprange)
    5              0.000056 		exe printf(pcmd, ke, pfunc, va)
    6              0.000004 	endfo
    1              0.000002 	let s:nmapped = s:bufnr

FUNCTION  ctrlp#getcline()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2601
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000007 	let [linenr, offset] = [line('.'), ( s:offset > 0 ? s:offset : 0 )]
    1              0.000008 	retu !empty(s:lines) && !( offset && linenr <= offset ) ? s:lines[linenr - 1 - offset] : ''

FUNCTION  <SNR>38_offset()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1695
Called 13 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
   13              0.000050 	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
   13              0.000035 	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines

FUNCTION  <SNR>38_ignore()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:11
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000011 	let igdirs = [ '\.git', '\.hg', '\.svn', '_darcs', '\.bzr', '\.cdv', '\~\.dep', '\~\.dot', '\~\.nib', '\~\.plst', '\.pc', '_MTN', 'blib', 'CVS', 'RCS', 'SCCS', '_sgbak', 'autom4te\.cache', 'cover_db', '_build', ]
    1              0.000006 	let igfiles = [ '\~$', '#.+#$', '[._].*\.swp$', 'core\.\d+$', '\.exe$', '\.so$', '\.bak$', '\.png$', '\.jpg$', '\.gif$', '\.zip$', '\.rar$', '\.tar\.gz$', ]
    1              0.000029 	retu { 'dir': '\v[\/]('.join(igdirs, '|').')$', 'file': '\v'.join(igfiles, '|'), }

FUNCTION  <SNR>20_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/plugin/matchparen.vim:39
Called 29 times
Total time:   0.002741
 Self time:   0.002741

count  total (s)   self (s)
                              " Remove any previous match.
   29              0.000125   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   29              0.000017   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   29              0.000122   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   29              0.000015   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   29              0.000082   let c_lnum = line('.')
   29              0.000118   let c_col = col('.')
   29              0.000053   let before = 0
                            
   29              0.000080   let text = getline(c_lnum)
   29              0.000435   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   29              0.000063   if empty(matches)
                                let [c_before, c] = ['', '']
   29              0.000019   else
   29              0.000137     let [c_before, c] = matches[1:2]
   29              0.000026   endif
   29              0.000546   let plist = split(&matchpairs, '.\zs[:,]')
   29              0.000098   let i = index(plist, c)
   29              0.000039   if i < 0
                                " not found, in Insert mode try character before the cursor
   29              0.000090     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   29              0.000020     endif
   29              0.000025     if i < 0
                                  " not found, nothing to do
   29              0.000028       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>38_openfile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2431
Called 1 time
Total time:   0.050756
 Self time:   0.005699

count  total (s)   self (s)
    1              0.000003 	let cmd = a:cmd
    1   0.000042   0.000028 	if a:chkmod && cmd =~ '^[eb]$' && ctrlp#modfilecond(!( cmd == 'b' && &aw ))
                            		let cmd = cmd == 'b' ? 'sb' : 'sp'
    1              0.000001 	en
    1              0.000007 	let cmd = cmd =~ '^tab' ? ctrlp#tabcount().cmd : cmd
    1              0.000004 	let j2l = a:0 && a:1[0] ? a:1[1] : 0
    1   0.050199   0.005596 	exe cmd.( a:0 && a:1[0] ? '' : a:tail ) s:fnesc(a:fid, 'f')
    1              0.000005 	if j2l
                            		cal ctrlp#j2l(j2l)
    1              0.000002 	en
    1              0.000004 	if !empty(a:tail)
                            		sil! norm! zvzz
    1              0.000001 	en
    1              0.000003 	if cmd != 'bad'
    1   0.000471   0.000031 		cal ctrlp#setlcdir()
    1              0.000001 	en

FUNCTION  <SNR>38_unmarksigns()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2000
Called 14 times
Total time:   0.000193
 Self time:   0.000133

count  total (s)   self (s)
   14   0.000191   0.000131 	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo

FUNCTION  <SNR>38_multipliers()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1589
Called 374 times
Total time:   0.004654
 Self time:   0.004654

count  total (s)   self (s)
  374              0.000847 	let mp0 = !a:1 ? 0 : 2
  374              0.000918 	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
  374              0.000861 	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
  374              0.000905 	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
  374              0.000742 	retu [mp0, mp1, mp2, mp3]

FUNCTION  <SNR>38_comparent()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1525
Called 374 times
Total time:   0.083039
 Self time:   0.022183

count  total (s)   self (s)
                            	" By same parent dir
  374              0.001228 	if !stridx(s:crfpath, s:dyncwd)
  374   0.020875   0.007990 		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
  374   0.057421   0.009450 		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
  374              0.001478 		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
  374              0.001123 		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
  374              0.000329 		retu 0
                            	en
                            	retu 0

FUNCTION  <SNR>38_PrtAdd()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:816
Called 9 times
Total time:   0.267851
 Self time:   0.000380

count  total (s)   self (s)
    9              0.000039 	unl! s:hstgot
    9              0.000049 	let s:act_add = 1
    9              0.000069 	let s:prompt[0] .= a:char
    9   0.267659   0.000188 	cal s:BuildPrompt(1)
    9              0.000015 	unl s:act_add

FUNCTION  ctrlp#clra()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:363
Called 1 time
Total time:   0.001510
 Self time:   0.000434

count  total (s)   self (s)
    1   0.000058   0.000054 	let cadir = ctrlp#utils#cachedir()
    1              0.000069 	if isdirectory(cadir)
    1   0.000915   0.000088 		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
    1              0.000004 		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
    1   0.000436   0.000201 		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
    1              0.000002 	en
    1   0.000024   0.000014 	cal ctrlp#clr()

FUNCTION  <SNR>38_IsBuiltin()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2690
Called 1 time
Total time:   0.000028
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004 	let builtins = ['tag', 'dir', 'bft', 'rts', 'bkd', 'lns', 'chs', 'mix', 'udo', 'qfx']
    1   0.000019   0.000007 	let curtype = s:getextvar('sname')
    1              0.000002 	return s:itemtype < len(s:coretypes) || index(builtins, curtype) > -1

FUNCTION  <SNR>38_MapSpecs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1067
Called 1 time
Total time:   0.001055
 Self time:   0.001055

count  total (s)   self (s)
    1              0.000003 	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
    1              0.000042 		if ( has('termresponse') && v:termresponse =~ "\<ESC>" ) || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi|tmux|st(-[-a-z0-9]*)?(\:tc)?$'
    5              0.000006 			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
    4              0.000034 				exe s:lcmap.' <esc>['.each
    5              0.000004 			endfo
    1              0.000000 		en
    1              0.000001 	en
  123              0.000153 	for [ke, va] in items(s:prtmaps) | for kp in va
   53              0.000673 		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
  123              0.000077 	endfo | endfo
    1              0.000002 	let s:smapped = s:bufnr

FUNCTION  ctrlp#setpathmode()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1849
Called 1 time
Total time:   0.002516
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000004 	if a:pmode == 'c' || ( a:pmode == 'a' && stridx(s:crfpath, s:cwd) < 0 )
                            		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
                            		cal ctrlp#setdir(s:crfpath)
                            		retu 1
    1              0.000001 	elsei a:pmode == 'r'
    1              0.000002 		let spath = a:0 ? a:1 : s:crfpath
    1              0.000003 		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
    1              0.000004 		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu 1 | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            			let markers = s:rmarkers + markers
    1              0.000001 		en
    1   0.002485   0.000015 		if s:findroot(spath, markers, 0, 0) != [] | retu 1 | en
                            	en
                            	retu 0

FUNCTION  ctrlp#setlcdir()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1881
Called 1 time
Total time:   0.000440
 Self time:   0.000112

count  total (s)   self (s)
    1              0.000007 	if exists('*haslocaldir')
    1   0.000427   0.000099 		cal ctrlp#setdir(getcwd(), haslocaldir() ? 'lc!' : 'cd!')
    1              0.000004 	en

FUNCTION  <SNR>38_stop_job_if_exists()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:485
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003 	if exists('s:job')
                            		if !has('nvim')
                            			cal job_stop(s:job)
                            		else
                            			cal jobstop(s:job)
                            		endif
                            		unlet s:job
    1              0.000001 	en

FUNCTION  <SNR>38_CurTypeName()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2673
Called 578 times
Total time:   0.009576
 Self time:   0.009576

count  total (s)   self (s)
  578              0.001789 	if s:itemtype < len(s:coretypes)
  578              0.007375 		return filter(copy(s:coretypes), 'v:val[1]==g:ctrlp_types[s:itemtype]')[0]
                            	el
                            		return [s:getextvar("lname"), s:getextvar('sname')]
                            	en

FUNCTION  <SNR>38_nosplit()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2133
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000026 	retu !empty(s:nosplit) && match([bufname('%'), &l:ft, &l:bt], s:nosplit) >= 0

FUNCTION  ctrlp#progress()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1649
Called 12 times
Total time:   0.018981
 Self time:   0.018981

count  total (s)   self (s)
   12              0.016256 	if has('macunix') || has('mac') | sl 1m | en
   12              0.000079 	let txt = a:0 ? '(press ctrl-c to abort)' : ''
   12              0.000040 	if s:status != {}
                            		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'str': a:enum }] : [a:enum]
                            		let &l:stl = call(s:status['prog'], argms, s:status)
   12              0.000009 	el
   12              0.000208 		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
   12              0.000011 	en
   12              0.002239 	redraws

FUNCTION  <SNR>37_lash()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:12
Called 4 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    4              0.000050 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  ctrlp#igncwd()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1744
Called 1 time
Total time:   0.000162
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000161   0.000030 	retu ctrlp#utils#glob(a:cwd, 0) == '' || ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )

FUNCTION  <SNR>38_Update()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:743
Called 14 times
Total time:   0.324030
 Self time:   0.002381

count  total (s)   self (s)
                            	" Get the previous string if existed
   14              0.000114 	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
   14   0.001637   0.000319 	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
   14              0.000114 	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
                            	" Optionally send the string to a custom validate function
   13              0.000073 	if s:validate != '' | let str = call(s:validate, [str]) | en
   13              0.000112 	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
   13   0.004409   0.000394 	let pat = s:matcher == {} ? s:SplitPattern(str) : str
   13   0.040471   0.000831 	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines) : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
   13              0.000079 	if empty(str) | cal clearmatches() | en
   13   0.276916   0.000240 	cal s:Render(lines, pat)
   13              0.000015 	return lines

FUNCTION  <SNR>38_opts()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:226
Called 1 time
Total time:   0.000643
 Self time:   0.000586

count  total (s)   self (s)
    1              0.000002 	unl! s:usrign s:usrcmd s:urprtmaps
    6              0.000020 	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
                            		let {each} = s:{each}
    6              0.000005 	en | endfo
   47              0.000093 	for [ke, va] in items(s:opts)
   46              0.000225 		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
   47              0.000034 	endfo
    1              0.000001 	unl va
    6              0.000015 	for [ke, va] in items(s:new_opts)
    5              0.000030 		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
    6              0.000003 	endfo
    1              0.000001 	unl va
    4              0.000010 	for [ke, va] in items(s:lc_opts)
    3              0.000009 		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
    3              0.000003 		en
    4              0.000001 	endfo
                            	" Match window options
    1   0.000069   0.000018 	cal s:match_window_opts()
                            	" One-time values
    1              0.000002 	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
    1              0.000001 	en
    4              0.000008 	for each in ['byfname', 'regexp'] | if exists(each)
                            		let s:{each} = {each}
    4              0.000003 	en | endfo
    1              0.000004 	if !exists('g:ctrlp_tilde_homedir') | let g:ctrlp_tilde_homedir = 0 | en
    1              0.000003 	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
    1              0.000003 	let s:maxdepth = min([s:maxdepth, 100])
    1              0.000002 	let s:glob = s:showhidden ? '.*\|*' : '*'
    1              0.000004 	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
    1   0.000015   0.000009 	let s:lash = ctrlp#utils#lash()
    1              0.000001 	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
    1              0.000000 	en
    1              0.000001 	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
    1              0.000001 	en
                            	" Extensions
    1              0.000003 	if !( exists('extensions') && extensions == s:extensions )
    1              0.000002 		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
    1              0.000001 		endfo
    1              0.000001 	en
                            	" Keymaps
    1              0.000002 	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
    1              0.000001 	en

FUNCTION  <SNR>38_matchlens()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1544
Called 1375 times
Total time:   0.079115
 Self time:   0.060094

count  total (s)   self (s)
 1375              0.008603 	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
 1251              0.002114 	let st   = a:0 ? a:1 : 0
 1251              0.002064 	let lens = a:0 >= 2 ? a:2 : {}
 1251              0.001686 	let nr   = a:0 >= 3 ? a:3 : 0
 1251              0.002423 	if nr > 20 | retu {} | en
 1251              0.010823 	if match(a:str, a:pat, st) >= 0
  627              0.014266 		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
  627              0.004167 		let lens = extend(lens, { nr : [strlen(mst), mst] })
  627              0.003028 		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
 1251              0.000836 	en
 1251              0.001102 	retu lens

FUNCTION  <SNR>38_lash()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1736
Called 771 times
Total time:   0.013354
 Self time:   0.013354

count  total (s)   self (s)
  771              0.012959 	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''

FUNCTION  <SNR>38_SplitPattern()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:673
Called 13 times
Total time:   0.004015
 Self time:   0.002569

count  total (s)   self (s)
   13              0.000053 	let str = a:str
   13              0.000047 	let s:savestr = str
   13              0.000031 	if s:regexp
                            		let pat = s:regexfilter(str)
   13              0.000026 	el
   13              0.000238 		let lst = split(str, '\zs')
   13              0.000074 		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
   13              0.000014 		en
   52              0.000199 		for each in ['^', '$', '.']
   39              0.000488 			cal map(lst, 'escape(v:val, each)')
   52              0.000205 		endfo
   13              0.000015 	en
   13              0.000050 	if exists('lst')
   13              0.000059 		let pat = ''
   13              0.000046 		if !empty(lst)
   11   0.001098   0.000274 			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
   11              0.000013 			el
   11   0.000836   0.000214 				let pat = s:buildpat(lst)
   11              0.000008 			en
   13              0.000007 		en
   13              0.000007 	en
   13              0.000052 	retu escape(pat, '~')

FUNCTION  <SNR>6_LoadFTPlugin()
    Defined: /usr/local/Cellar/vim/8.2.0250_1/share/vim/vim82/ftplugin.vim:14
Called 2 times
Total time:   0.002452
 Self time:   0.001317

count  total (s)   self (s)
    2              0.000007     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000001     endif
                            
    2              0.000006     let s = expand("<amatch>")
    2              0.000004     if s != ""
    2              0.000013       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    2              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000014       for name in split(s, '\.')
    2   0.002378   0.001243 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    4              0.000008       endfor
    2              0.000002     endif

FUNCTION  <SNR>38_setupblank()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2137
Called 1 time
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
    1              0.000319 	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
    1              0.000036 	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
    1              0.000005 	if v:version > 702
    1              0.000074 		setl nornu noudf cc=0
    1              0.000002 	en
    1              0.000003 	if s:has_conceal
    1              0.000014 		setl cole=2 cocu=nc
    1              0.000001 	en

FUNCTION  <SNR>38_execextvar()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2584
Called 3 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    3              0.000016 	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars), 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
    3              0.000003 	en

FUNCTION  ctrlp#mrufiles#bufs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:129
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002 	retu s:mrbs

FUNCTION  <SNR>38_MatchIt()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:626
Called 13 times
Total time:   0.037212
 Self time:   0.035780

count  total (s)   self (s)
   13              0.000059 	let [lines, id] = [[], 0]
   13   0.000951   0.000233 	let pat = s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val') : s:martcs.a:pat
 1054              0.001286 	for item in a:items
 1053              0.001349 		let id += 1
 1053              0.000829 		try
 1053              0.019378 			if (s:matchcrfile || !( s:ispath && item ==# a:exc )) &&call(s:mfunc, [item, pat]) >= 0
  124              0.000416 				cal add(lines, item)
 1053              0.000752 			en
 1053              0.000863 		cat | brea | endt
 2093              0.003280 		if a:limit > 0 && len(lines) >= a:limit | brea | en
 1054              0.001057 	endfo
   13   0.001622   0.000908 	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
   13              0.000042 	retu lines

FUNCTION  ctrlp#statusline()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1601
Called 15 times
Total time:   0.001661
 Self time:   0.001530

count  total (s)   self (s)
   15              0.000043 	if !exists('s:statypes')
    1              0.000003 		let s:statypes = copy(s:coretypes)
    1              0.000002 		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars), 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
    1              0.000000 		en
   15              0.000007 	en
   15              0.000024 	let tps = s:statypes
   15              0.000047 	let max = len(tps) - 1
   15   0.000263   0.000195 	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
   15   0.000244   0.000181 	let prv = tps[s:walker(max, s:itemtype, -1)][1]
   15              0.000040 	let s:ctype = tps[s:itemtype][0]
   15              0.000026 	let focus   = s:focus ? 'prt'  : 'win'
   15              0.000033 	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
   15              0.000072 	let marked  = s:opmul != '0' ? exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
   15              0.000030 	if s:status != {}
                            		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'focus':   focus, 'byfname': byfname, 'regex':   s:regexp, 'prev':    prv, 'item':    s:ctype, 'next':    nxt, 'marked':  marked, }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
                            		let &l:stl = call(s:status['main'], argms, s:status)
   15              0.000009 	el
   15              0.000040 		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
   15              0.000034 		let focus   = '%#CtrlPMode2# '.focus.' %*'
   15              0.000032 		let byfname = '%#CtrlPMode1# '.byfname.' %*'
   15              0.000022 		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
   15              0.000065 		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
   15              0.000025 		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
   15              0.000218 		let &l:stl  = focus.byfname.regex.slider.marked.dir
   15              0.000040 		if exists('s:timer')
                            			let &l:stl = '%#CtrlPStats# '.len(g:ctrlp_allfiles).' '.&l:stl
   15              0.000011 		en
   15              0.000005 	en

FUNCTION  ctrlp#utils#readfile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:44
Called 3 times
Total time:   0.000672
 Self time:   0.000672

count  total (s)   self (s)
    3              0.000100 	if filereadable(a:file)
    3              0.000538 		let data = readfile(a:file)
    3              0.000016 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
    3              0.000003 		en
    3              0.000003 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>38_setlines_post()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2657
Called 1 time
Total time:   0.265743
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004 	let inits = {'fil': 'ctrlp#files()', 'buf': 'ctrlp#buffers()', 'mru': 'ctrlp#mrufiles#list()'}
    1              0.000008 	let types = map(copy(g:ctrlp_types), 'inits[v:val]')
    1              0.000002 	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
    1              0.000001 	en
    1   0.265721   0.000016 	let g:ctrlp_lines = eval(types[s:itemtype])
    1              0.000003 	let s:setlines_post_ended = 1

FUNCTION  <SNR>38_PrtSelectMove()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:947
Called 2 times
Total time:   0.002629
 Self time:   0.000161

count  total (s)   self (s)
    2              0.000018 	let wht = winheight(0)
    2              0.000024 	let dirs = {'t': 'gg','b': 'G','j': 'j','k': 'k','u': wht.'k','d': wht.'j'}
    2              0.000033 	exe 'keepj norm!' dirs[a:dir]
    2              0.000020 	let pos = exists('*getcurpos') ? getcurpos() : getpos('.')
    2   0.002517   0.000049 	cal s:BuildPrompt(0)
    2              0.000010 	cal setpos('.', pos)

FUNCTION  ctrlp#files()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:381
Called 1 time
Total time:   0.265705
 Self time:   0.017070

count  total (s)   self (s)
    1   0.000076   0.000012 	let cafile = ctrlp#utils#cachefile()
    1              0.000015 	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
    1   0.000018   0.000013 		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
    1              0.000002 		if empty(lscmd)
    1   0.000169   0.000007 			if !ctrlp#igncwd(s:dyncwd)
    1   0.000018   0.000012 				cal s:InitCustomFuncs()
    1   0.213293   0.000040 				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
    1   0.000021   0.000014 				cal s:CloseCustomFuncs()
    1              0.000000 			en
                            		el
                            			sil! cal ctrlp#progress('Indexing...')
                            			try | cal s:UserCmd(lscmd)
                            			cat | retu [] | endt
    1              0.000001 		en
                            		" Remove base directory
    1   0.000484   0.000012 		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
    1              0.000003 		if len(g:ctrlp_allfiles) <= s:compare_lim
    1   0.030177   0.016822 			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
    1              0.000001 		en
    1   0.021325   0.000014 		cal s:writecache(cafile)
    1              0.000049 		let catime = getftime(cafile)
                            	el
                            		let catime = getftime(cafile)
                            		if !( exists('s:initcwd') && s:initcwd == s:dyncwd ) || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
    1              0.000001 	en
    1              0.000018 	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
    1              0.000003 	retu g:ctrlp_allfiles

FUNCTION  <SNR>38_lastvisual()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2401
Called 1 time
Total time:   0.000122
 Self time:   0.000108

count  total (s)   self (s)
    1              0.000010 	let cview = winsaveview()
    1              0.000006 	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
    1              0.000006 	let [oureg, outype] = [getreg('"'), getregtype('"')]
    1              0.000020 	sil! norm! gV"vy
    1   0.000036   0.000022 	let selected = s:regisfilter('v')
    1              0.000010 	cal setreg('v', ovreg, ovtype)
    1              0.000006 	cal setreg('"', oureg, outype)
    1              0.000024 	cal winrestview(cview)
    1              0.000004 	retu selected

FUNCTION  <SNR>38_regisfilter()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2263
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000013 	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')

FUNCTION  <SNR>38_formatline()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1663
Called 124 times
Total time:   0.009065
 Self time:   0.005540

count  total (s)   self (s)
  124              0.000179 	let str = a:str
  124   0.003825   0.001011 	let ct = s:curtype()
  124              0.000146 	if ct == 'buf'
                            		let bufnr = s:bufnrfilpath(str)[0]
                            		let parts = s:bufparts(bufnr)
                            		let str = printf('%'.s:bufnr_width.'s', bufnr)
                            		if s:has_conceal && has('syntax_items')
                            			let str .= printf(' %-13s %s%-36s', '<bi>'.parts[0].'</bi>', '<bn>'.parts[1], '{'.parts[2].'}</bn>')
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', '<bp>'.parts[3].'</bp>')
                            			en
                            		el
                            			let str .= printf(' %-5s %-30s', parts[0], parts[2])
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', parts[3])
                            			en
                            		en
  124              0.000063 	en
  124   0.002142   0.001431 	let cond = ct != 'buf' &&s:ispath && ( s:winw - 4 ) < s:strwidth(str)
  124              0.000391 	retu s:lineprefix.( cond ? s:pathshorten(str) : str )

FUNCTION  <SNR>38_mixedsort()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1562
Called 374 times
Total time:   0.253086
 Self time:   0.051836

count  total (s)   self (s)
  374   0.014980   0.003778 	let ct = s:curtype()
  374              0.000558 	if ct == 'buf'
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
  374              0.000228 	en
  374   0.096470   0.009235 	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
  374              0.000384 	if s:ispath
  374              0.000479 		let ms = []
  374              0.000475 		if s:res_count < 21
  374   0.012332   0.005144 			let ms += [s:compfnlen(a:1, a:2)]
  374   0.015707   0.007775 			if ct !~ '^\(buf\|mru\)$' | let ms += [s:comptime(a:1, a:2)] | en
  374   0.089019   0.005980 			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
  374              0.000184 		en
  374              0.002126 		if ct =~ '^\(buf\|mru\)$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
  374              0.000220 		en
  374              0.001419 		let ms += [cml, 0, 0, 0]
  374   0.011097   0.006443 		let mp = call('s:multipliers', ms[:3])
  374              0.002018 		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2

FUNCTION  <SNR>38_buildpat()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2497
Called 11 times
Total time:   0.000622
 Self time:   0.000622

count  total (s)   self (s)
   11              0.000044 	let pat = a:lst[0]
   11              0.000019 	if s:matchnatural == 1
                            		for item in range(1, len(a:lst) - 1)
                            			let c = a:lst[item - 1]
                            			let pat .= (c == '/' ? '[^/]\{-}' : '[^'.c.'/]\{-}').a:lst[item]
                            		endfo
   11              0.000010 	els
   30              0.000111 		for item in range(1, len(a:lst) - 1)
   19              0.000141 			let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
   30              0.000042 		endfo
   11              0.000012 	en
   11              0.000016 	retu pat

FUNCTION  <SNR>38_PrtExit()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1020
Called 1 time
Total time:   0.022328
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000004 	let bw = bufwinnr('%')
    1              0.000009 	exe bufwinnr(s:bufnr).'winc w'
    1              0.000006 	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
    1   0.022295   0.000028 		noa cal s:Close()
    1              0.000008 		noa winc p
                            	els
                            		exe bw.'winc w'
    1              0.000000 	en

FUNCTION  <SNR>38_fnesc()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1877
Called 112 times
Total time:   0.008281
 Self time:   0.001745

count  total (s)   self (s)
  112   0.008187   0.001651 	retu call('ctrlp#utils#fnesc', a:000)

FUNCTION  ctrlp#recordhist()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1990
Called 1 time
Total time:   0.021266
 Self time:   0.000181

count  total (s)   self (s)
    1              0.000008 	let str = join(s:prompt, '')
    1              0.000004 	if empty(str) || !s:maxhst | retu | en
    1              0.000002 	let hst = s:hstry
    1              0.000022 	if len(hst) > 1 && hst[1] == str | retu | en
    1              0.000007 	cal extend(hst, [str], 1)
    1              0.000008 	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
    1   0.021212   0.000127 	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])

FUNCTION  <SNR>38_usrign()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1774
Called 519 times
Total time:   0.087054
 Self time:   0.087054

count  total (s)   self (s)
  519              0.001496 	if s:igntype == 1 | retu a:item =~ s:usrign | en
  519              0.000479 	if s:igntype == 2
                            		if call(s:usrign, [a:item, a:type])
                            			retu 1
                            		en
  519              0.000498 	elsei s:igntype == 4
  519              0.078148 		if has_key(s:usrign, a:type) && s:usrign[a:type] != '' && a:item =~ s:usrign[a:type]
   98              0.000147 			retu 1
  421              0.001752 		elsei has_key(s:usrign, 'func') && s:usrign['func'] != '' && call(s:usrign['func'], [a:item, a:type])
                            			retu 1
  421              0.000236 		en
  421              0.000243 	en
  421              0.000359 	retu 0

FUNCTION  ctrlp#rmbasedir()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1798
Called 1 time
Total time:   0.000472
 Self time:   0.000456

count  total (s)   self (s)
    1              0.000001 	if a:items == []
                            		retu a:items
    1              0.000001 	en
    1   0.000025   0.000009 	let cwd = s:dyncwd.s:lash()
    1              0.000003 	let first = a:items[0]
    1              0.000015 	if has('win32') || has('win64')
                            		let cwd = tr(cwd, '\', '/')
                            		let first = tr(first, '\', '/')
    1              0.000001 	en
    1              0.000004 	if !stridx(first, cwd)
    1              0.000004 		let idx = strlen(cwd)
    1              0.000410 		retu map(a:items, 'strpart(v:val, idx)')
                            	en
                            	retu a:items

FUNCTION  ctrlp#utils#fnesc()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:78
Called 113 times
Total time:   0.006574
 Self time:   0.006574

count  total (s)   self (s)
  113              0.000421 	if exists('*fnameescape')
  113              0.000385 		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
  113              0.000070 		el
  113              0.001786 			let path = fnameescape(a:path)
  113              0.000101 		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
  113              0.000067 	en
  113              0.000616 	retu a:0 ? escape(path, a:1) : path

FUNCTION  <SNR>38_Reset()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:373
Called 1 time
Total time:   0.000819
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000004 	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
    1   0.000658   0.000015 	cal call('s:opts', opts)
    1   0.000028   0.000014 	cal s:autocmds()
    1   0.000108   0.000012 	cal ctrlp#utils#opts()
    1   0.000020   0.000013 	cal s:execextvar('opts')

FUNCTION  ctrlp#utils#mkdir()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:56
Called 4 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    4              0.000076 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
    4              0.000004 	en
    4              0.000018 	retu a:dir

FUNCTION  <SNR>38_highlight()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1914
Called 13 times
Total time:   0.002698
 Self time:   0.002340

count  total (s)   self (s)
   13              0.000038 	if s:matcher != {} | retu | en
   13              0.000047 	cal clearmatches()
   13              0.000026 	if !empty(a:pat) && s:ispath
   11              0.000007 		if s:regexp
                            			let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            			cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
   11              0.000005 		el
   11              0.000014 			let pat = a:pat
                            
                            			" get original characters so we can rebuild pat
   11              0.000132 			let chars = split(pat, '\[\^\\\?.\]\\{-}')
                            
                            			" Build a pattern like /a.*b.*c/ from abc (but with .\{-} non-greedy
                            			" matchers instead)
   11              0.000042 			let pat = join(chars, '.\{-}')
                            			" Ensure we match the last version of our pattern
   11              0.000026 			let ending = '\(.*'.pat.'\)\@!'
                            			" Case sensitive?
   11              0.000031 			let beginning = ( s:martcs == '' ? '\c' : '\C' ).'^.*'
   11   0.000455   0.000097 			if s:byfname()
                            				" Make sure there are no slashes in our match
                            				let beginning = beginning.'\([^\/]*$\)\@='
   11              0.000009 			en
                            
   41              0.000076 			for i in range(len(chars))
                            				" Surround our current target letter with \zs and \ze so it only
                            				" actually matches that one letter, but has all preceding and trailing
                            				" letters as well.
                            				" \zsa.*b.*c
                            				" a\(\zsb\|.*\zsb)\ze.*c
   30              0.000089 				let charcopy = copy(chars)
   30              0.000026 				if i == 0
   11              0.000042 					let charcopy[i] = '\zs'.charcopy[i].'\ze'
   11              0.000034 					let middle = join(charcopy, '.\{-}')
   19              0.000011 				el
   19              0.000084 					let before = join(charcopy[0:i-1], '.\{-}')
   19              0.000075 					let after = join(charcopy[i+1:-1], '.\{-}')
   19              0.000033 					let c = charcopy[i]
                            					" for abc, match either ab.\{-}c or a.*b.\{-}c in that order
   19              0.000059 					let cpat = '\(\zs'.c.'\|'.'.*\zs'.c.'\)\ze.*'
   19              0.000044 					let middle = before.cpat.after
   30              0.000017 				en
                            
                            				" Now we matchadd for each letter, the basic form being:
                            				" ^.*\zsx\ze.*$, but with our pattern we built above for the letter,
                            				" and a negative lookahead ensuring that we only highlight the last
                            				" occurrence of our letters. We also ensure that our matcher is case
                            				" insensitive or sensitive depending.
   30              0.000266 				cal matchadd(a:grp, beginning.middle.ending)
   41              0.000181 			endfo
   11              0.000008 		en
                            
   11              0.000056 		cal matchadd('CtrlPLinePre', '^>')
    2              0.000007 	elseif !empty(a:pat) && s:regexp && exists('g:ctrlp_regex_always_higlight') && g:ctrlp_regex_always_higlight
                            		let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C').pat)
   13              0.000007 	en

FUNCTION  <SNR>14_record()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 3 times
Total time:   0.014375
 Self time:   0.000218

count  total (s)   self (s)
    3              0.000012 	if s:locked | retu | en
    3              0.000012 	let bufnr = a:bufnr + 0
    3              0.000011 	let bufname = bufname(bufnr)
    3              0.000026 	if bufnr > 0 && !empty(bufname)
    3              0.000026 		cal filter(s:mrbs, 'v:val != bufnr')
    3              0.000012 		cal insert(s:mrbs, bufnr)
    3   0.014236   0.000079 		cal s:addtomrufs(bufname)
    3              0.000004 	en

FUNCTION  ctrlp#syntax()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1887
Called 1 time
Total time:   0.001466
 Self time:   0.001087

count  total (s)   self (s)
    1   0.000028   0.000017 	if ctrlp#nosy() | retu | en
   51   0.000658   0.000342 	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
    1              0.000014 	let bgColor=synIDattr(synIDtrans(hlID('Normal')), 'bg')
    1              0.000012 	if bgColor !~ '^-1$\|^$'
    1              0.000498 		sil! exe 'hi CtrlPLinePre guifg='.bgColor.' ctermfg='.bgColor
    1              0.000004 	en
    1              0.000017 	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
    1              0.000009 	if hlexists('CtrlPLinePre')
    1              0.000019 		exe "sy match CtrlPLinePre '^".escape(get(g:, 'ctrlp_line_prefix', '>'),'^$.*~\')."'"
    1              0.000001 	en
                            
    1   0.000088   0.000036 	if s:curtype() == 'buf' && s:has_conceal
                            		sy region CtrlPBufferNr     matchgroup=CtrlPLinePre start='^>\s\+' end='\s'
                            		sy region CtrlPBufferInd    concealends matchgroup=Ignore start='<bi>' end='</bi>'
                            		sy region CtrlPBufferRegion concealends matchgroup=Ignore start='<bn>' end='</bn>' contains=CtrlPBufferHid,CtrlPBufferHidMod,CtrlPBufferVis,CtrlPBufferVisMod,CtrlPBufferCur,CtrlPBufferCurMod
                            		sy region CtrlPBufferHid    concealends matchgroup=Ignore     start='\s*{' end='}' contained
                            		sy region CtrlPBufferHidMod concealends matchgroup=Ignore    start='+\s*{' end='}' contained
                            		sy region CtrlPBufferVis    concealends matchgroup=Ignore   start='\*\s*{' end='}' contained
                            		sy region CtrlPBufferVisMod concealends matchgroup=Ignore  start='\*+\s*{' end='}' contained
                            		sy region CtrlPBufferCur    concealends matchgroup=Ignore  start='\*!\s*{' end='}' contained
                            		sy region CtrlPBufferCurMod concealends matchgroup=Ignore start='\*+!\s*{' end='}' contained
                            		sy region CtrlPBufferPath   concealends matchgroup=Ignore start='<bp>' end='</bp>'
    1              0.000002 	en

FUNCTION  <SNR>38_SetWD()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:1160
Called 1 time
Total time:   0.002671
 Self time:   0.000155

count  total (s)   self (s)
    1              0.000009 	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0 && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
    1              0.000001 	en
    1              0.000006 	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
    1              0.000001 	en
    1              0.000007 	let pmodes = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
    1              0.000068 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
    1              0.000004 	if (!type(pmodes))
                            		let pmodes = pmodes == 0 ? '' : pmodes == 1 ? 'a' : pmodes == 2 ? 'r' : 'c'
    1              0.000001 	en
    1              0.000009 	let spath = pmodes =~ 'd' ? s:dyncwd : pmodes =~ 'w' ? s:cwd : s:crfpath
    1              0.000010 	for pmode in split(pmodes, '\zs')
    1   0.002540   0.000024 		if ctrlp#setpathmode(pmode, spath) | retu | en
                            	endfo

FUNCTION  <SNR>14_mergelists()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:31
Called 2 times
Total time:   0.000420
 Self time:   0.000190

count  total (s)   self (s)
    2   0.000261   0.000051 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    2              0.000097 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    2              0.000014 	let mrufs = s:mrufs + diskmrufs
    2   0.000045   0.000025 	retu s:chop(mrufs)

FUNCTION  ctrlp#modfilecond()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2128
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000014 	retu &mod && !&hid && &bh != 'hide' && s:bufwins(bufnr('%')) == 1 && !&cf && ( ( !&awa && a:w ) || filewritable(fnamemodify(bufname('%'), ':p')) != 1 )

FUNCTION  <SNR>38_mfunc()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp.vim:2516
Called 1 time
Total time:   0.000128
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000002 	let mfunc = 'match'
    1   0.000065   0.000011 	if s:byfname()
                            		let mfunc = 's:matchfname'
    1   0.000043   0.000012 	elsei s:curtype() == 'buf'
                            		let mfunc = 's:matchbuf'
    1              0.000003 	elsei s:itemtype >= len(s:coretypes)
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
    1              0.000001 	en
    1              0.000001 	retu mfunc

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   13   1.111859   0.008508  <SNR>38_GlobPath()
   15   0.364751   0.036658  <SNR>38_BuildPrompt()
   14   0.324030   0.002381  <SNR>38_Update()
    1   0.299504   0.000320  ctrlp#init()
   13   0.276676   0.009638  <SNR>38_Render()
    9   0.268226   0.000375  <SNR>38_PrtFocusMap()
    9   0.267851   0.000380  <SNR>38_PrtAdd()
    1   0.265743   0.000038  <SNR>38_setlines_post()
    1   0.265705   0.017070  ctrlp#files()
  374   0.253086   0.051836  <SNR>38_mixedsort()
   13   0.113865   0.026577  ctrlp#dirnfile()
  519   0.087054             <SNR>38_usrign()
  374   0.083941   0.018696  <SNR>38_compmatlen()
  374   0.083039   0.022183  <SNR>38_comparent()
 1375   0.079115   0.060094  <SNR>38_matchlens()
    4   0.077000   0.076826  ctrlp#utils#writecache()
    3   0.074637   0.000219  <SNR>38_PrtBS()
    1   0.074332   0.000151  <SNR>38_AcceptSelection()
    1   0.074049   0.000279  ctrlp#acceptfile()
    1   0.050756   0.005699  <SNR>38_openfile()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  519              0.087054  <SNR>38_usrign()
    4   0.077000   0.076826  ctrlp#utils#writecache()
 1375   0.079115   0.060094  <SNR>38_matchlens()
  374   0.253086   0.051836  <SNR>38_mixedsort()
  750              0.048100  <SNR>38_getparent()
   15   0.364751   0.036658  <SNR>38_BuildPrompt()
   13   0.037212   0.035780  <SNR>38_MatchIt()
   13   0.113865   0.026577  ctrlp#dirnfile()
  374   0.083039   0.022183  <SNR>38_comparent()
   12              0.018981  ctrlp#progress()
  374   0.083941   0.018696  <SNR>38_compmatlen()
    1   0.265705   0.017070  ctrlp#files()
 2918              0.016649  ctrlp#complen()
  771              0.013354  <SNR>38_lash()
   13   0.276676   0.009638  <SNR>38_Render()
  578              0.009576  <SNR>38_CurTypeName()
   13   1.111859   0.008508  <SNR>38_GlobPath()
  374              0.007932  <SNR>38_comptime()
  577   0.017178   0.007625  <SNR>38_curtype()
  374              0.007188  <SNR>38_compfnlen()

